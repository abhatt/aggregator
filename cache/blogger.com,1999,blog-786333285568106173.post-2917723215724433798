<?xml version="1.0" encoding="utf-8"?><entry xmlns="http://www.w3.org/2005/Atom" xmlns:planet="http://planet.intertwingly.net/"><id>tag:blogger.com,1999:blog-786333285568106173.post-2917723215724433798</id><link href="http://infoweekly.blogspot.com/feeds/2917723215724433798/comments/default" rel="replies" type="application/atom+xml"/><link href="http://www.blogger.com/comment.g?blogID=786333285568106173&amp;postID=2917723215724433798" rel="replies" type="text/html"/><link href="http://www.blogger.com/feeds/786333285568106173/posts/default/2917723215724433798" rel="edit" type="application/atom+xml"/><link href="http://www.blogger.com/feeds/786333285568106173/posts/default/2917723215724433798" rel="self" type="application/atom+xml"/><link href="http://infoweekly.blogspot.com/2010/09/static-1d-range-reporting.html" rel="alternate" type="text/html"/><title>Static 1D Range Reporting</title><content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">Method 4 for implementing van Emde Boas with linear space, described in my last post, is due to [Alstrup, Brodal, Rauhe: STOC'01]. They worked on static range reporting in 1 dimension: preprocess a set of integers <i>S</i>, and answer query(<i>a</i>,<i>b</i>) = report all points in <i>S</i> ∩ [<i>a</i>,<i>b</i>]. This is easier than predecessor search: you can first find the predecessor of <i>a</i> and then output points in order until you exceed <i>b</i>. Using van Emde Boas, we would achieve a linear-space data structure with query time O(lglg <i>u</i> + <i>k</i>), where <i>k</i> is the number of points to be reported.<div><br/></div><div>Alstrup, Brodal, and Rauhe showed the following surprising result:<br/><blockquote>Static 1D range reporting can be solved with O(<i>n</i>) space and O(1+<i>k</i>) query time.<br/></blockquote> </div><div>I like this theorem a lot, since it is so easy to describe to anybody with minimal background in Computer Science, yet the result is not obvious. I have used it many times to answer questions like, &quot;Tell me a surprising recent result from data structures.&quot;</div><div><br/></div><div><b>The solution. </b>We need a way to find <i>some </i>(arbitrary) key from <i>S</i> ∩ [a,b] in constant time. Once we have that, we can walk left and right in an ordered list until we go outside the interval.</div><div><br/></div><div>Let's first see how to do this with O(<i>n</i> lg <i>u</i>) space; this was described by [Miltersen, Nisan, Safra, Wigderson: STOC'95]. Of course, we build the trie representing the set. Given the query [<i>a</i>,<i>b</i>] let us look at the lowest common ancestor (LCA) of <i>a</i> and <i>b</i>. Note that LCA(<i>a</i>,<i>b</i>) is a simple mathematical function of the integers <i>a</i> and <i>b</i>, and can be computed in constant time. (The height of the LCA is the most significant set bit in <i>a</i> xor <i>b</i>.)</div><div><ul><li>if LCA(<i>a</i>,<i>b</i>) is a branching node, look at the two descendant branching nodes. If the interval [<i>a</i>,<i>b</i>] is nonempty, it must contain either the max in the tree of the left child, or the min in the tree of the right child.<br/><br/></li><li>if LCA(<i>a</i>,<i>b</i>) is an active node, go to its lowest branching ancestor, and do something like the the above.<br/><br/></li><li>if LCA(<i>a</i>,<i>b</i>) is not an active node, the interval [<i>a</i>,<i>b</i>] is certainly empty!</li></ul><div>Thus, it suffices to find the lowest branching ancestor of LCA(<i>a</i>,<i>b</i>) <u>assuming</u> that LCA(<i>a</i>,<i>b</i>) is active. This is significantly easier than predecessor search, which needs the lowest branching ancestor of an arbitrary node.</div></div><div><br/></div><div>The proposal of [Miltersen et al.] is to store all O(<i>n</i> lg <i>u</i>) active nodes in a hash table, with pointers to their lowest branching ancestors.</div><div><br/></div><div>As in my <a href="http://infoweekly.blogspot.com/2010/09/veb-space-method-4.html">last post</a>, the technique of [Alstrup et al.] to achieve O(<i>n</i>) space is: store only O(<i>n</i> √<span>lg <i>u</i></span>) active nodes, and store them in a retrieval-only dictionary with O(lglg <i>u</i>) bits per node. We store the following active nodes:</div><div><ol><li>active nodes at depth i·√<span style="text-decoration: overline;">lg <i>u</i></span> ;</li><li>active nodes less than √<span>lg <i>u</i></span> levels below a branching node.</li></ol></div><div>We first look up LCA(<i>a</i>,<i>b</i>) in the dictionary. If the lowest branching ancestor is less than  √<span>lg <i>u</i></span> levels above, LCA(<i>a</i>,<i>b</i>) is in the dictionary and we find the ancestor. If not, we truncate the depth of the LCA to a multiple of √<span>lg <i>u</i></span> , and look up the ancestor at that depth. If [a,b] is nonempty, that ancestor must be an active node and it will point us to a branching ancestor.</div></div><div class="commentbar"><p/><span class="commentbutton" href="http://infoweekly.blogspot.com/feeds/2917723215724433798/comments/default"/><a href="http://infoweekly.blogspot.com/feeds/2917723215724433798/comments/default"><img class="commenticon" src="/images/feed-icon.png"/> Subscribe to comments</a><![CDATA[  | ]]><a href="http://www.blogger.com/comment.g?blogID=786333285568106173&amp;postID=2917723215724433798"><img class="commenticon" src="/images/post-icon.png"/> Post a comment</a></div></content><updated planet:format="September 21, 2010 05:20 PM">2010-09-21T17:20:00Z</updated><published planet:format="September 21, 2010 05:20 PM">2010-09-21T17:20:00Z</published><author><name>Mihai</name><email>noreply@blogger.com</email><uri>http://www.blogger.com/profile/11599372864611039927</uri></author><source><id>tag:blogger.com,1999:blog-786333285568106173</id><author><name>Mihai</name><email>noreply@blogger.com</email><uri>http://www.blogger.com/profile/11599372864611039927</uri></author><link href="http://infoweekly.blogspot.com/" rel="alternate" type="text/html"/><link href="http://www.blogger.com/feeds/786333285568106173/posts/default?start-index=26&amp;max-results=25&amp;redirect=false" rel="next" type="application/atom+xml"/><link href="http://feeds.feedburner.com/WebdiariosDeMotocicleta" rel="self" type="application/atom+xml"/><link href="http://pubsubhubbub.appspot.com/" rel="hub" type="text/html"/><subtitle>Informatics Weekly, written by Mihai Pătraşcu.</subtitle><title>WebDiarios de Motocicleta</title><updated planet:format="September 17, 2018 03:40 AM">2018-09-17T03:40:52Z</updated><planet:module>toc</planet:module><planet:format>atom10</planet:format><planet:http_etag>p4aBUs7EfDbSpgYtTTaw3ObCwMk</planet:http_etag><planet:http_last_modified>Sun, 16 Dec 2018 15:48:09 GMT</planet:http_last_modified><planet:bozo>false</planet:bozo><planet:items_per_page>40</planet:items_per_page><planet:css-id>webdiarios-de-motocicleta</planet:css-id><planet:face>mihai.jpg</planet:face><planet:name>WebDiarios de Motocicleta</planet:name><planet:http_status>200</planet:http_status></source></entry>
