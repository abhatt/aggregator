<?xml version="1.0" encoding="utf-8"?><entry xmlns="http://www.w3.org/2005/Atom" xmlns:planet="http://planet.intertwingly.net/"><id>tag:blogger.com,1999:blog-4068183698747623113.post-5031685703664530875</id><link href="http://teachingintrotocs.blogspot.com/feeds/5031685703664530875/comments/default" rel="replies" type="application/atom+xml"/><link href="http://teachingintrotocs.blogspot.com/2011/10/testing-sortedness.html#comment-form" rel="replies" type="text/html"/><link href="http://www.blogger.com/feeds/4068183698747623113/posts/default/5031685703664530875" rel="edit" type="application/atom+xml"/><link href="http://www.blogger.com/feeds/4068183698747623113/posts/default/5031685703664530875" rel="self" type="application/atom+xml"/><link href="http://teachingintrotocs.blogspot.com/2011/10/testing-sortedness.html" rel="alternate" type="text/html"/><title>Testing Sortedness</title><content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">Sofya Raskhodnikova, in a talk, presented a  problem that could be taught at the end of the semester of my undergraduate Algorithms course. It can be solved by elementary means using randomization. (It can also be tied to the problem of finding the longest increasing subsequence of an input sequence, a classic illustration of algorithmic techniques.) This builds on two papers, &quot;Improved testing algorithms for monotonicity&quot; by Dodis-Goldreich-Lehman-Raskhodnikov-Ron-Samorodnitsky, and &quot;Transitive-Closure Spanners&quot; by Bhattacharyya-Grigorescu-Jung-Raskhodnikova-Woodruff.<br/><br/>Given an array A of n items (numbers), you wish to check, quickly, whether the items are sorted or nearly sorted. By &quot;check&quot;, I mean, with reasonable confidence (say, you're correct with probability 99%). By &quot;quickly&quot;, I  mean in logarithmic time. By &quot;nearly sorted&quot;, I mean that only a few of the numbers are out of place: if we ignore 4% of the numbers (outliers), the rest is sorted. <br/><br/>Why would you wish to check that? Maybe, if you have some data that used to be sorted but that, after some lazy updates, is now slightly out of order, to test whether you should bother sorting your data again; or, if you're about to resort, to decide which sorting algorithm to use. <br/><br/>Here is the algorithm. <br/><br/>- Define a set S of n log n &quot;edges&quot; (pairs of items). Assuming A is in sorted order, those are the pairs that would have been compared if you had sorted using Quicksort and if your pivot was always the median of the subset of numbers being sorted in the current recursive call. Thus there are edges between A[n/2] and everybody else, edges between A[n/4] and everyone in the range [1...n/2], edges between A[3n/4] and everyone in the range (n/2..n], etc. <br/>- Repeat log n times: pick an edge {i,j} from S uniformly at random, and check whether A[i] and A[j] are in the correct order relative to each other.<br/>- Output &quot;The array is nearly sorted&quot; if and only if all the checks are successful.<br/><br/>Here is the analysis.<br/><br/>- If A is sorted then obviously all checks are successful and the output is correct<br/>- If A is not sorted but is nearly sorted, with fewer than 4% of the items out of order, then the output could go either way. <br/>- If A is far from being sorted, the central claim is that  at least 0.01 n edges of S would fail the check. Then one of those edges would (probably) be found after a logarithmic number of tries.<br/><br/>Why does the claim hold? <br/><br/>Create a  graph with vertex set A and with an edge between every pair {i,j} such that {A[i],A[j]} are in the wrong order. Note that the outliers are a minimum cardinality vertex cover of that graph. It is known (basic approximation algorithms fact) that the maximum matching M has size at least 1/2 times the minimum vertex cover, |M| &gt;= |S|/2. <br/><br/>Mark the two endpoints of every edge of S that would fail the check.  The number of edges of S that would fail the check is at least half of the number of marked vertices. For each {i,j} in the matching M defined above, by definition of Quicksort there is a k between i and j such that {i,k} and {k,j} are both in S. The central observation is that, since {A[i],A[j]} are in the wrong order, it must be that {A[i],A[k]} or {A[k],A[j]} are in the wrong order, so either i or j or both are marked. So the number of marked vertices is greater than or equal to  |M|. <br/><br/>Putting those observations together, the number of edges of S that would fail the check is at least half of the number of marked vertices, so it is at least half  the size of M, so it is at least a quarter of the number of outliers. So, if there are at least .04 n outliers, then there are at least .01 n edges of S that would fail their check. This proves the claim.</div><div class="commentbar"><p/><span class="commentbutton" href="http://teachingintrotocs.blogspot.com/feeds/5031685703664530875/comments/default"/><a href="http://teachingintrotocs.blogspot.com/feeds/5031685703664530875/comments/default"><img class="commenticon" src="/images/feed-icon.png"/> Subscribe to comments</a><![CDATA[  | ]]><a href="http://teachingintrotocs.blogspot.com/2011/10/testing-sortedness.html#comment-form"><img class="commenticon" src="/images/post-icon.png"/> Post a comment</a></div></content><updated planet:format="October 19, 2011 12:11 PM">2011-10-19T12:11:00Z</updated><published planet:format="October 19, 2011 12:11 PM">2011-10-19T12:11:00Z</published><category scheme="http://www.blogger.com/atom/ns#" term="TCS"/><author><name>Claire Mathieu</name><email>noreply@blogger.com</email><uri>http://www.blogger.com/profile/10957755706440077623</uri></author><source><id>tag:blogger.com,1999:blog-4068183698747623113</id><category term="TCS"/><category term="Oops"/><category term="technology"/><author><name>Claire Mathieu</name><email>noreply@blogger.com</email><uri>http://www.blogger.com/profile/10957755706440077623</uri></author><link href="http://teachingintrotocs.blogspot.com/feeds/posts/default" rel="http://schemas.google.com/g/2005#feed" type="application/atom+xml"/><link href="http://www.blogger.com/feeds/4068183698747623113/posts/default/-/TCS" rel="self" type="application/atom+xml"/><link href="http://teachingintrotocs.blogspot.com/search/label/TCS" rel="alternate" type="text/html"/><link href="http://pubsubhubbub.appspot.com/" rel="hub" type="text/html"/><title>A CS Professor's blog</title><updated planet:format="August 31, 2018 11:03 AM">2018-08-31T11:03:02Z</updated><planet:module>toc</planet:module><planet:format>atom10</planet:format><planet:http_etag>W/&quot;8089cd57e1113cac488458ecc6b57d2f5d63c2f2cb0051d1de6e12d23ed12d82&quot;</planet:http_etag><planet:http_last_modified>Fri, 31 Aug 2018 11:03:02 GMT</planet:http_last_modified><planet:bozo>false</planet:bozo><planet:items_per_page>40</planet:items_per_page><planet:css-id>claire-mathieu</planet:css-id><planet:face>mathieu.jpeg</planet:face><planet:name>Claire Mathieu</planet:name><planet:filters>category.py?cats=tcs</planet:filters><planet:http_status>200</planet:http_status></source></entry>

