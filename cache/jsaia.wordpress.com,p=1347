<?xml version="1.0" encoding="utf-8"?><entry xml:lang="en" xmlns="http://www.w3.org/2005/Atom" xmlns:planet="http://planet.intertwingly.net/"><id>http://jsaia.wordpress.com/?p=1347</id><link href="https://jsaia.wordpress.com/2015/06/20/1347/" rel="alternate" type="text/html"/><title>Simon’s Institute Workshop on Securing Computation</title><summary>[The following report on the Securing Computation Workshop at the Simons Institute was written by my students Mahnush Movahedi and Mahdi Zamani. A polished version of this report is available HERE.] 2015 Workshop on Securing Computation June 8-12, Simons Institute for the Theory of Computing, University of California, Berkeley Lower Bounds for Information-Theoretic MPC, Ivan […]<div class="commentbar"><p/></div></summary><content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p style="text-align: justify;"><i>[The following report on the Securing Computation Workshop at the Simons Institute was written by my students <a href="http://www.cs.unm.edu/~movahedi">Mahnush Movahedi</a> and <a href="http://www.cs.unm.edu/~zamani">Mahdi Zamani</a>. </i><em>A polished version of this report is available <a href="http://cs.unm.edu/~zamani/notes/sc15">HERE.</a>]</em></p>
<h3 style="text-align: justify;"><a class="URL" href="http://simons.berkeley.edu/workshops/crypto2015-1">2015 Workshop on Securing Computation</a></h3>
<h3 style="text-align: justify;">June 8-12, Simons Institute for the Theory of Computing, University of California, Berkeley</h3>
<hr class="line"/>
<h3 class="Subsubsection-" style="text-align: justify;">Lower Bounds for Information-Theoretic MPC, <i>Ivan Damgård</i>,<i> Aarhus University</i></h3>
<div class="Unindented" style="text-align: justify;">Ivan started his talk by comparing unconditional <i>multi-party computation (MPC)</i> protocols to cryptographic techniques such as FHE: The unconditional protocols are usually much more computationally-efficient than FHE protocols. On the other hand, unconditional techniques usually require lots of interactions and their round complexity is usually large. One interesting question to ask here is that “Is it possible to design an unconditionally-secure FHE that has the benefits of both schemes?” The answer is, unfortunately, still unknown, but we have some partial answers. The goal here is to determine how many messages we need to transmit in order to compute a non-trivial function (such as the AND of bits each coming from one player) securely. Ivan argued that if there are <span class="MathJax_Preview"><span class="MathJax" id="MathJax-Element-2-Frame"><span class="math" id="MathJax-Span-3"><span class="mrow" id="MathJax-Span-4"><span class="mi" id="MathJax-Span-5">n</span></span></span></span></span> players with <span class="MathJax_Preview"><span class="MathJax" id="MathJax-Element-3-Frame"><span class="math" id="MathJax-Span-6"><span class="mrow" id="MathJax-Span-7"><span class="mi" id="MathJax-Span-8">t</span></span></span></span></span> semi-honest corruptions, the protocol must send <span class="MathJax_Preview"><span class="MathJax" id="MathJax-Element-4-Frame"><span class="math" id="MathJax-Span-9"><span class="mrow" id="MathJax-Span-10"><span class="mi" id="MathJax-Span-11">Ω</span><span class="mo" id="MathJax-Span-12">(</span><span class="mi" id="MathJax-Span-13">n</span><span class="mi" id="MathJax-Span-14">t</span><span class="mo" id="MathJax-Span-15">)</span></span></span></span></span> messages. For example, for <span class="MathJax_Preview"><span class="MathJax" id="MathJax-Element-5-Frame"><span class="math" id="MathJax-Span-16"><span class="mrow" id="MathJax-Span-17"><span class="mi" id="MathJax-Span-18">n</span><span class="mo" id="MathJax-Span-19">=</span><span class="mn" id="MathJax-Span-20">3</span></span></span></span></span> and <span class="MathJax_Preview"><span class="MathJax" id="MathJax-Element-6-Frame"><span class="math" id="MathJax-Span-21"><span class="mrow" id="MathJax-Span-22"><span class="mi" id="MathJax-Span-23">t</span><span class="mo" id="MathJax-Span-24">=</span><span class="mn" id="MathJax-Span-25">1</span></span></span></span></span>, we need to send at least six messages to compute the AND functionality. The intuition behind this is that every player must communicate with at least <span class="MathJax_Preview"><span class="MathJax" id="MathJax-Element-7-Frame"><span class="math" id="MathJax-Span-26"><span class="mrow" id="MathJax-Span-27"><span class="mi" id="MathJax-Span-28">t</span><span class="mo" id="MathJax-Span-29">+</span><span class="mn" id="MathJax-Span-30">1</span></span></span></span></span> players, and must later receive another message to compute the output. So, for each player we count <span class="MathJax_Preview"><span class="MathJax" id="MathJax-Element-8-Frame"><span class="math" id="MathJax-Span-31"><span class="mrow" id="MathJax-Span-32"><span class="mo" id="MathJax-Span-33">(</span><span class="mi" id="MathJax-Span-34">t</span><span class="mo" id="MathJax-Span-35">+</span><span class="mn" id="MathJax-Span-36">1</span><span class="mo" id="MathJax-Span-37">)</span><span class="mo" id="MathJax-Span-38">+</span><span class="mn" id="MathJax-Span-39">2</span></span></span></span></span> messages sent or received, and thus the total becomes at least <span class="MathJax_Preview"><span class="MathJax" id="MathJax-Element-9-Frame"><span class="math" id="MathJax-Span-40"><span class="mrow" id="MathJax-Span-41"><span class="mi" id="MathJax-Span-42">n</span><span class="mo" id="MathJax-Span-43">(</span><span class="mi" id="MathJax-Span-44">t</span><span class="mo" id="MathJax-Span-45">+</span><span class="mn" id="MathJax-Span-46">3</span><span class="mo" id="MathJax-Span-47">)</span><span class="texatom" id="MathJax-Span-48"><span class="mrow" id="MathJax-Span-49"><span class="mo" id="MathJax-Span-50">/</span></span></span><span class="mn" id="MathJax-Span-51">2</span></span></span></span></span> messages sent. One thing that I should point out here (and which my own research touches on) is that they assume all-to-all communication. Several protocols (such as <span class="bibcites">[<a class="bibliocite" href="http://cs.unm.edu/%7Ezamani/notes/sc15/#biblio-5" name="cite-5"><span class="bib-Sur">DKMS</span><span class="bib-YY">12</span></a>, <a class="bibliocite" href="http://cs.unm.edu/%7Ezamani/notes/sc15/#biblio-2" name="cite-2"><span class="bib-Sur">BGT</span><span class="bib-YY">13</span></a>, <a class="bibliocite" href="http://cs.unm.edu/%7Ezamani/notes/sc15/#biblio-6" name="cite-6"><span class="bib-Sur">DKMS</span><span class="bib-YY">14</span></a>]</span>) break this lower bound by requiring each party to only communicate with a small (polylog size) set of parties (see <span class="bibcites">[<a class="bibliocite" href="http://cs.unm.edu/%7Ezamani/notes/sc15/#biblio-11" name="cite-11"><span class="bib-Sur">SZ</span><span class="bib-YY">15</span></a>]</span> for a complete discussion on sublinear MPC results).</div>
<div class="Indented" style="text-align: justify;">
<div class="wrap-r">
<div class="figure">
<div class="right">
<p><img alt="figure 20150610_160437.jpg" class="embedded aligncenter" src="https://i2.wp.com/cs.unm.edu/~zamani/notes/sc15/20150610_160437.jpg" style="width: 464px; height: 261px;"/></p>
<div class="caption" style="text-align: center;">Figure 1. Calvin Lab Auditorium (<a class="URL" href="http://cs.unm.edu/~zamani/notes/sc15/20150610_160437.jpg">enlarge</a>)</div>
</div>
</div>
</div>
</div>
<div class="Indented" style="text-align: justify;">Bounding the communication and rounds needed in general seems hard. But, it might be possible to bound these for the <i>gate-by-gate</i> protocols, where a circuit is evaluated gate-by-gate: the invariant is that we secret-share the inputs to each gate, and then evaluate the gate functionality over the secret-shared inputs to generate the gate output. Known protocols with this strategy have <span class="MathJax_Preview"><span class="MathJax" id="MathJax-Element-10-Frame"><span class="math" id="MathJax-Span-52"><span class="mrow" id="MathJax-Span-53"><span class="mi" id="MathJax-Span-54">Ω</span><span class="mo" id="MathJax-Span-55">(</span><span class="mi" id="MathJax-Span-56">n</span><span class="texatom" id="MathJax-Span-57"><span class="mrow" id="MathJax-Span-58"><span class="mo" id="MathJax-Span-59">|</span></span></span><span class="mi" id="MathJax-Span-60">C</span><span class="texatom" id="MathJax-Span-61"><span class="mrow" id="MathJax-Span-62"><span class="mo" id="MathJax-Span-63">|</span></span></span><span class="mo" id="MathJax-Span-64">)</span></span></span></span></span> communication complexity and <span class="MathJax_Preview"><span class="MathJax" id="MathJax-Element-11-Frame"><span class="math" id="MathJax-Span-65"><span class="mrow" id="MathJax-Span-66"><span class="mi" id="MathJax-Span-67">Ω</span><span class="mo" id="MathJax-Span-68">(</span><span class="texatom" id="MathJax-Span-69"><span class="mrow" id="MathJax-Span-70"><span class="mo" id="MathJax-Span-71">|</span></span></span><span class="mi" id="MathJax-Span-72">C</span><span class="texatom" id="MathJax-Span-73"><span class="mrow" id="MathJax-Span-74"><span class="mo" id="MathJax-Span-75">|</span></span></span><span class="mo" id="MathJax-Span-76">)</span></span></span></span></span> round complexity, where <span class="MathJax_Preview"><span class="MathJax" id="MathJax-Element-12-Frame"><span class="math" id="MathJax-Span-77"><span class="mrow" id="MathJax-Span-78"><span class="texatom" id="MathJax-Span-79"><span class="mrow" id="MathJax-Span-80"><span class="mo" id="MathJax-Span-81">|</span></span></span><span class="mi" id="MathJax-Span-82">C</span><span class="texatom" id="MathJax-Span-83"><span class="mrow" id="MathJax-Span-84"><span class="mo" id="MathJax-Span-85">|</span></span></span></span></span></span></span> is the circuit size. But, are these optimal? The bottleneck for gate-by-gate protocols is the multiplication gate, which Ivan argues to take at least <span class="MathJax_Preview"><span class="MathJax" id="MathJax-Element-13-Frame"><span class="math" id="MathJax-Span-86"><span class="mrow" id="MathJax-Span-87"><span class="mi" id="MathJax-Span-88">t</span></span></span></span></span> message to be evaluated. Thus, the best known results are asymptotically optimal. Ivan then finished his talk by showing that the same lower bounds exist for the case of dishonest majority, where a preprocessing phase is necessary for MPC. Thus, to really improve the existing protocols, we need a fundamentally different approach.</div>
<h3 class="Subsubsection-" style="text-align: justify;">Obfuscation: Past, Present, and Possible Futures, <i>Amit Sahai</i>,<i> UCLA</i></h3>
<p style="text-align: justify;">In program obfuscation, a given program <span class="MathJax_Preview"><span class="MathJax" id="MathJax-Element-14-Frame"><span class="math" id="MathJax-Span-89"><span class="mrow" id="MathJax-Span-90"><span class="msubsup" id="MathJax-Span-91"><span class="mi" id="MathJax-Span-92">P</span><span class="texatom" id="MathJax-Span-93"><span class="mrow" id="MathJax-Span-94"><span class="mn" id="MathJax-Span-95">1</span></span></span></span></span></span></span></span> is converted to another program <span class="MathJax_Preview"><span class="MathJax" id="MathJax-Element-15-Frame"><span class="math" id="MathJax-Span-96"><span class="mrow" id="MathJax-Span-97"><span class="msubsup" id="MathJax-Span-98"><span class="mi" id="MathJax-Span-99">P</span><span class="texatom" id="MathJax-Span-100"><span class="mrow" id="MathJax-Span-101"><span class="mn" id="MathJax-Span-102">2</span></span></span></span></span></span></span></span> that represents the same functionality (i.e., the same I/O) while an adversary who can see <span class="MathJax_Preview"><span class="MathJax" id="MathJax-Element-16-Frame"><span class="math" id="MathJax-Span-103"><span class="mrow" id="MathJax-Span-104"><span class="msubsup" id="MathJax-Span-105"><span class="mi" id="MathJax-Span-106">P</span><span class="texatom" id="MathJax-Span-107"><span class="mrow" id="MathJax-Span-108"><span class="mn" id="MathJax-Span-109">2</span></span></span></span></span></span></span></span> cannot understand its logic. From a cryptographic perspective, this is like having a software that can keep a secret. This leads to a new notion of program obfuscation called <i>indistinguishability obfuscation (iO)</i>, where a polynomial-time adversary cannot distinguish between the obfuscations of two equivalent programs. The first mathematical construction of an indistinguishability obfuscator was proposed by Garg-Gentry-Halevi in 2013. The main idea to obfuscate programs using structured noise rather than just random noise. When the program is evaluated, the noise cancels out and the correct output is obtained.</p>
<p>To this end, a <i>multilinear map</i> can be used to encode field elements with specific algebraic manipulations and a Boolean function that returns Yes/No when the encoded value is zero or not. The program is first converted to a sequence matrices using a technique called oblivious matrix branching program. Then, the Kilian’s randomization technique is used to generate structured noise: the matrices are multiplied by a sequence of random matrices. The key challenge to the current obfuscation scheme is the input-mixing attack. A technique is required to enforce honest behavior in some way. Amit finished his talk by arguing that multilinear maps provide a new hardness generating technique at the level of Diffie-Hellman and learning with error hardness assumptions, but they have mainly been used for obfuscation. One open question is that can multilinear maps be used for solving other security problems?</p>
<h3 class="Subsubsection-" style="text-align: justify;">Two-Round MPC via Multi-Key FHE,<i> Daniel Wichs, Northeastern University</i></h3>
<div class="Unindented" style="text-align: justify;">Daniel started his talk by asking two motivating questions: (1) Can we construct MPC with minimal round complexity? (2) Can we construct MPC directly using FHE techniques? A <i>fully homomorphic encryption (FHE)</i> scheme allows to perform secure computation over encrypted data without decrypting it <span class="bibcites">[<a class="bibliocite" href="https://jsaia.wordpress.com/feed/#biblio-7" name="cite-7"><span class="bib-Sur">Gen</span><span class="bib-YY">09</span></a>]</span>. Asharov et al. <span class="bibcites">[<a class="bibliocite" href="https://jsaia.wordpress.com/feed/#biblio-1" name="cite-1"><span class="bib-Sur">AJLTVW</span><span class="bib-YY">12</span></a>]</span> show how FHE can be used to construct constant-round MPC by designing a <i>threshold FHE (TFHE)</i> technique that provides Byzantine-resilience and circuit-independent communication cost. All parties first encrypt their inputs under an FHE scheme (such as that of <span class="bibcites">[<a class="bibliocite" href="https://jsaia.wordpress.com/feed/#biblio-3" name="cite-3"><span class="bib-Sur">BGV</span><span class="bib-YY">12</span></a>]</span>) and send the encrypted values to all other parties. Then, each party evaluates the desired function over the encrypted inputs via homomorphism, and eventually participates in a <i>distributed decryption</i> protocol to decrypt the output. This protocol requires a <i>distributed key generation </i>algorithm to agree on a common public key and a secret-shared private key. While the MPC protocol of <span class="bibcites">[<a class="bibliocite" href="https://jsaia.wordpress.com/feed/#biblio-1" name="cite-1"><span class="bib-Sur">AJLTVW</span><span class="bib-YY">12</span></a>]</span> requires three rounds of communication, Daniel described a new FHE-based MPC protocol that requires only two rounds of communication. This result as well as <span class="bibcites">[<a class="bibliocite" href="https://jsaia.wordpress.com/feed/#biblio-1" name="cite-1"><span class="bib-Sur">AJLTVW</span><span class="bib-YY">12</span></a>]</span> are secure in the common random string (CRS) model<span class="FootOuter"><span class="SupFootMarker">  (</span><span class="HoverFoot"><span class="SupFootMarker"> a</span>n algorithm is secure in the CRS model if it assumes that all parties have access to a common random string taken from a predetermined distribution)</span></span>. This assumption is required for malicious security in both work. Also, both results require a <i>non-interactive zero-knowledge (NIZK)</i> technique to enforce honest behavior in the malicious setting.</div>
<div class="Indented" style="text-align: justify;">The idea of the new result is to remove the first round (distributed key generation) of the protocol: Each party chooses its own individual public key and secret key pair with coordinating with other parties, encrypts its input under that public key, and broadcasts the ciphertext. But how to compute over ciphertext generated by these uncoordinated keys and decrypt the result? The key idea is to use a <i>multi-key FHE</i> scheme that can compute over a set ciphertext each encrypted with a different key. The result will be another ciphertext that can only be decrypted with a certain number of private keys. Recently, Clear and McGoldrick <span class="bibcites">[<a class="bibliocite" href="https://jsaia.wordpress.com/feed/#biblio-9" name="cite-9"><span class="bib-Sur">CM</span><span class="bib-YY">14</span></a>]</span> proposed a multi-key FHE scheme using the <i>learning with error (LWE)</i> hardness assumption<span class="FootOuter"><span class="SupFootMarker">  (t</span><span class="HoverFoot">he LWE problem asks to recover a secret from a sequence of “approximate” random linear equations<span class="MathJax_Preview">// </span>. Algorithms based on the LWE assumption belong to the so-called <i>post-quantum cryptography</i>, where the security cannot be broken in feasible time even using a quantum computer)</span></span>.</div>
<h3 class="Subsubsection-" style="text-align: justify;">Efficient Multiparty Protocols via Log-Depth Threshold Formulae, <i>Ron Rothblum</i>,<i> Weizmann Institute</i></h3>
<div class="Unindented" style="text-align: justify;">Ron presented a new approach for designing multi-party computation protocols when there are more than two parties. Their approach is motivated by the fact that the huge body of work on MPC are very complicated; there is a need for a simple and flexible approach. The basic technique that they propose is called <i>player emulation</i>; the computational task run by a player is emulated by other players. This allows us to reduce the construction of an <span class="MathJax_Preview">// </span>-party protocol to the construction of (small) constant-party protocols which are much easier to design. This idea consists of two steps:</div>
<ol style="text-align: justify;">
<li>Design a protocol for a small number of parties (say, 3 or 4) which achieves security against a single corrupted party. Such protocols are typically easy to construct as they may employ techniques that do not scale well with the number of corrupted parties.</li>
<li>Recursively compose with itself to obtain an efficient n-party protocol which achieves security against a constant fraction of corrupted parties.</li>
</ol>
<div class="Unindented" style="text-align: justify;">
<p>The reduction idea is described in the following. First, consider a trivial <span class="MathJax_Preview"><span class="MathJax" id="MathJax-Element-20-Frame"><span class="math" id="MathJax-Span-119"><span class="mrow" id="MathJax-Span-120"><span class="mi" id="MathJax-Span-121">n</span></span></span></span></span>-party setting that includes a trusted party <span class="MathJax_Preview"><span class="MathJax" id="MathJax-Element-21-Frame"><span class="math" id="MathJax-Span-122"><span class="mrow" id="MathJax-Span-123"><span class="mi" id="MathJax-Span-124">τ</span></span></span></span></span>. The parties send their inputs to <span class="MathJax_Preview"><span class="MathJax" id="MathJax-Element-22-Frame"><span class="math" id="MathJax-Span-125"><span class="mrow" id="MathJax-Span-126"><span class="mi" id="MathJax-Span-127">τ</span></span></span></span></span> whom locally computes the MPC functionality and returns the output back to all parties. Now, replace the trusted party with a small constant number of virtual parties, say <span class="MathJax_Preview"><span class="MathJax" id="MathJax-Element-23-Frame"><span class="math" id="MathJax-Span-128"><span class="mrow" id="MathJax-Span-129"><span class="msubsup" id="MathJax-Span-130"><span class="mi" id="MathJax-Span-131">v</span><span class="texatom" id="MathJax-Span-132"><span class="mrow" id="MathJax-Span-133"><span class="mn" id="MathJax-Span-134">1</span></span></span></span><span class="mo" id="MathJax-Span-135">,</span><span class="msubsup" id="MathJax-Span-136"><span class="mi" id="MathJax-Span-137">v</span><span class="texatom" id="MathJax-Span-138"><span class="mrow" id="MathJax-Span-139"><span class="mn" id="MathJax-Span-140">2</span></span></span></span><span class="mo" id="MathJax-Span-141">,</span><span class="msubsup" id="MathJax-Span-142"><span class="mi" id="MathJax-Span-143">v</span><span class="texatom" id="MathJax-Span-144"><span class="mrow" id="MathJax-Span-145"><span class="mn" id="MathJax-Span-146">3</span></span></span></span></span></span></span></span>, which emulate the behavior of <span class="MathJax_Preview"><span class="MathJax" id="MathJax-Element-24-Frame"><span class="math" id="MathJax-Span-147"><span class="mrow" id="MathJax-Span-148"><span class="mi" id="MathJax-Span-149">τ</span></span></span></span></span>. The new protocol is secure as long as the adversary does not control a majority of the virtual parties. We now proceed by replacing <span class="MathJax_Preview"><span class="MathJax" id="MathJax-Element-25-Frame"><span class="math" id="MathJax-Span-150"><span class="mrow" id="MathJax-Span-151"><span class="msubsup" id="MathJax-Span-152"><span class="mi" id="MathJax-Span-153">v</span><span class="texatom" id="MathJax-Span-154"><span class="mrow" id="MathJax-Span-155"><span class="mn" id="MathJax-Span-156">1</span></span></span></span></span></span></span></span> by with three new virtual parties <span class="MathJax_Preview"><span class="MathJax" id="MathJax-Element-26-Frame"><span class="math" id="MathJax-Span-157"><span class="mrow" id="MathJax-Span-158"><span class="msubsup" id="MathJax-Span-159"><span class="mi" id="MathJax-Span-160">w</span><span class="texatom" id="MathJax-Span-161"><span class="mrow" id="MathJax-Span-162"><span class="mn" id="MathJax-Span-163">1</span></span></span></span><span class="mo" id="MathJax-Span-164">,</span><span class="msubsup" id="MathJax-Span-165"><span class="mi" id="MathJax-Span-166">w</span><span class="texatom" id="MathJax-Span-167"><span class="mrow" id="MathJax-Span-168"><span class="mn" id="MathJax-Span-169">2</span></span></span></span><span class="mo" id="MathJax-Span-170">,</span><span class="msubsup" id="MathJax-Span-171"><span class="mi" id="MathJax-Span-172">w</span><span class="texatom" id="MathJax-Span-173"><span class="mrow" id="MathJax-Span-174"><span class="mn" id="MathJax-Span-175">3</span></span></span></span></span></span></span></span>. The new protocol is secure even if the adversary controls either one of <span class="MathJax_Preview"><span class="MathJax" id="MathJax-Element-27-Frame"><span class="math" id="MathJax-Span-176"><span class="mrow" id="MathJax-Span-177"><span class="msubsup" id="MathJax-Span-178"><span class="mi" id="MathJax-Span-179">v</span><span class="texatom" id="MathJax-Span-180"><span class="mrow" id="MathJax-Span-181"><span class="mn" id="MathJax-Span-182">2</span></span></span></span><span class="mo" id="MathJax-Span-183">,</span><span class="msubsup" id="MathJax-Span-184"><span class="mi" id="MathJax-Span-185">v</span><span class="texatom" id="MathJax-Span-186"><span class="mrow" id="MathJax-Span-187"><span class="mn" id="MathJax-Span-188">3</span></span></span></span></span></span></span></span> and one of the <span class="MathJax_Preview"><span class="MathJax" id="MathJax-Element-28-Frame"><span class="math" id="MathJax-Span-189"><span class="mrow" id="MathJax-Span-190"><span class="mi" id="MathJax-Span-191">w</span></span></span></span></span>’s, or two of the <span class="MathJax_Preview"><span class="MathJax" id="MathJax-Element-29-Frame"><span class="math" id="MathJax-Span-192"><span class="mrow" id="MathJax-Span-193"><span class="mi" id="MathJax-Span-194">w</span></span></span></span></span>’s. Using this, Ron constructed a formula as shown in Figure <a class="Reference" href="http://cs.unm.edu/%7Ezamani/notes/sc15/#wrap:formulae1">2↑</a>, which can be used to build a formula for the entire protocol as shown in Figure <a class="Reference" href="http://cs.unm.edu/%7Ezamani/notes/sc15/#wrap:formulae2">3↓</a>, where the leaves are the real parties.</p>
<div class="wrap-r">
<div class="figure">
<div class="right">
<p><img alt="figure Capture3.jpg" class="embedded aligncenter" src="https://i2.wp.com/cs.unm.edu/~zamani/notes/sc15/Capture3.jpg" style="width: 288px; height: 230px;"/></p>
<div class="caption" style="text-align: center;">Figure 3. Threshold Formulae of the Entire Protocol (<a class="URL" href="http://cs.unm.edu/~zamani/notes/sc15/Capture3.jpg">enlarge</a>)</div>
</div>
</div>
</div>
</div>
<div class="Indented" style="text-align: justify;">Two things that are necessary for the new model to result in efficient MPC protocols are (1) a secure 3-party protocol; and (2) a logarithmic-depth formula that computes majority using only <span class="MathJax_Preview">// </span> gates. For the first requirement we can simply use the protocol of <span class="bibcites">[<a class="bibliocite" href="https://jsaia.wordpress.com/feed/#biblio-8" name="cite-8"><span class="bib-Sur">BGW</span><span class="bib-YY">88</span></a>]</span> over three parties. For the second one, Ron proposed two techniques. One is to use a randomized majority-from-majorities algorithm (this results in statistical security) and one using a deterministic but only close to optimal solution (see his <a class="URL" href="https://www.youtube.com/watch?v=dxSCtIg32co">talk</a> for more details). The new approach that Ron presented allows us to give new and conceptually simple proofs of classical MPC results such as <span class="bibcites">[<a class="bibliocite" href="https://jsaia.wordpress.com/feed/#biblio-8" name="cite-8"><span class="bib-Sur">BGW</span><span class="bib-YY">88</span></a>]</span>, and also design simple MPC protocols in the future.</div>
<h3 class="Subsubsection-" style="text-align: justify;">Rethinking Secure Computation – A Greedy Approach, <i>Muthu Venkitasubramaniam</i>,<i> University of Rochester</i></h3>
<div class="Unindented" style="text-align: justify;">
<p>The general framework for secure computation consists of two steps: (1) Compile a functionality into one of several standard representations such as a circuit (Boolean or arithmetic) or an oblivious RAM; (2) Use a generic scheme such as <span class="bibcites">[<a class="bibliocite" href="https://jsaia.wordpress.com/feed/#biblio-12" name="cite-12"><span class="bib-Sur">Yao</span><span class="bib-YY">82</span></a>, <a class="bibliocite" href="https://jsaia.wordpress.com/feed/#biblio-10" name="cite-10"><span class="bib-Sur">GMW</span><span class="bib-YY">87</span></a>, <a class="bibliocite" href="https://jsaia.wordpress.com/feed/#biblio-8" name="cite-8"><span class="bib-Sur">BGW</span><span class="bib-YY">88</span></a>, <a class="bibliocite" href="https://jsaia.wordpress.com/feed/#biblio-4" name="cite-4"><span class="bib-Sur">CCD</span><span class="bib-YY">88</span></a>]</span> to securely evaluate the functionality. However, for some certain problems such as Private Set Intersection, specific solutions can result in significantly more efficient solutions. Inspired by these, Muthu presented a new algorithmic approach for designing secure two-party computation protocols. In their model (join work with Abhi Shelat from UVA), they show that several problems such as convex hull, minimum spanning tree, unit job scheduling, and single source shortest path can be securely computed only by using secure comparison.</p>
<div class="wrap-r">
<div class="figure">
<div class="right">
<p><img alt="figure Capture.jpg" class="embedded aligncenter" src="https://i0.wp.com/cs.unm.edu/~zamani/notes/sc15/Capture.jpg" style="width: 445px; height: 314px;"/></p>
<div class="caption" style="text-align: center;">Figure 4. Abhi and Muthu’s Results (<a class="URL" href="http://cs.unm.edu/~zamani/notes/sc15/Capture.jpg">enlarge</a>)</div>
</div>
</div>
</div>
<p>The underlying idea among all of these problems is that each of them has some known greedy algorithm. Accordingly, Muthu described a new framework called <i>Greedy-Millionaire Framework</i>, where a function f is defined <i>secure greedy compatible</i> if there exists it has the following three properties:</p>
</div>
<ol style="text-align: justify;">
<li>Unique Solution: Given inputs <span class="MathJax_Preview"><span class="MathJax" id="MathJax-Element-32-Frame"><span class="math" id="MathJax-Span-207"><span class="mrow" id="MathJax-Span-208"><span class="mi" id="MathJax-Span-209">U</span></span></span></span></span> and <span class="MathJax_Preview"><span class="MathJax" id="MathJax-Element-33-Frame"><span class="math" id="MathJax-Span-210"><span class="mrow" id="MathJax-Span-211"><span class="mi" id="MathJax-Span-212">V</span></span></span></span></span> of Alice and Bob, <span class="MathJax_Preview"><span class="MathJax" id="MathJax-Element-34-Frame"><span class="math" id="MathJax-Span-213"><span class="mrow" id="MathJax-Span-214"><span class="mi" id="MathJax-Span-215">f</span><span class="mo" id="MathJax-Span-216">(</span><span class="mi" id="MathJax-Span-217">U</span><span class="mo" id="MathJax-Span-218">,</span><span class="mi" id="MathJax-Span-219">V</span><span class="mo" id="MathJax-Span-220">)</span></span></span></span></span> is unique;</li>
<li>Unique Order: There is a unique order in which the output is presented in the greedy algorithm;</li>
<li>Local Updatability: The local greedy heuristic can be computed using a comparison operation over the function locally computed over each of the inputs.</li>
</ol>
<div class="Unindented" style="text-align: justify;">Figure <a class="Reference" href="https://jsaia.wordpress.com/feed/muthu">4↑</a> shows the message complexity of their protocols for solving the listed problem using the Greedy-Millionaire framework. Their model currently supports secure computation in the semi-honest and covert settings. Other than extending their model to the malicious setting, one open problem here is that “Can we adapt their framework to model secure computation using other primitives rather than the secure comparison operation? For example, primitives that work for graph algorithms?”</div>
<h3 class="Subsubsection-" style="text-align: justify;">Cryptocurrencies and Smart Contracts, <i>Elaine Shi</i>,<i> University of Maryland</i></h3>
<div class="Unindented" style="text-align: justify;">Bitcoin is a decentralized cryptocurrency that can be used to perform secure computation using the concept of <i>blockchains</i>. A blockchain is a public ledger of all Bitcoin transactions that have ever been executed. It is constantly growing as “completed” blocks are added to it with a new set of recordings (read more about blockchains <a class="URL" href="http://www.investopedia.com/terms/b/blockchain.asp">here</a>). The blockchain used in bitcoin is guaranteed to be always correct but it does not guarantee privacy of users. Elaine described a <a class="URL" href="http://cs.unm.edu/~zamani/crypto/basics/page.html#toc-Subsection-12.2">universally-composable model</a> of the bitcoin protocol, where the functionality <span class="MathJax_Preview"><span class="MathJax" id="MathJax-Element-35-Frame"><span class="math" id="MathJax-Span-221"><span class="mrow" id="MathJax-Span-222"><span class="msubsup" id="MathJax-Span-223"><span class="mi" id="MathJax-Span-224">F_</span><span class="texatom" id="MathJax-Span-225"><span class="mrow" id="MathJax-Span-226"><span class="mi" id="MathJax-Span-227">b</span><span class="mi" id="MathJax-Span-228">l</span><span class="mi" id="MathJax-Span-229">o</span><span class="mi" id="MathJax-Span-230">c</span><span class="mi" id="MathJax-Span-231">k</span><span class="mi" id="MathJax-Span-232">c</span><span class="mi" id="MathJax-Span-233">h</span><span class="mi" id="MathJax-Span-234">a</span><span class="mi" id="MathJax-Span-235">i</span><span class="mi" id="MathJax-Span-236">n</span></span></span></span></span></span></span></span> exposes internal state of the blockchain to everyone, and the security proof is conducted in the <span class="MathJax_Preview"><span class="MathJax" id="MathJax-Element-36-Frame"><span class="math" id="MathJax-Span-237"><span class="mrow" id="MathJax-Span-238"><span class="msubsup" id="MathJax-Span-239"><span class="mi" id="MathJax-Span-240">F_</span><span class="texatom" id="MathJax-Span-241"><span class="mrow" id="MathJax-Span-242"><span class="mi" id="MathJax-Span-243">b</span><span class="mi" id="MathJax-Span-244">l</span><span class="mi" id="MathJax-Span-245">o</span><span class="mi" id="MathJax-Span-246">c</span><span class="mi" id="MathJax-Span-247">k</span><span class="mi" id="MathJax-Span-248">c</span><span class="mi" id="MathJax-Span-249">h</span><span class="mi" id="MathJax-Span-250">a</span><span class="mi" id="MathJax-Span-251">i</span><span class="mi" id="MathJax-Span-252">n</span></span></span></span></span></span></span></span>-hybrid model.</div>
<div class="Indented" style="text-align: justify;">Next, Elaine introduced <i>Ethereum</i>, a new cryptocurrency that consists of a ledger and user-defined smart contracts. The contracts run transactions (e.g., transfer x amount from y) over the ledger and the ledger ensures consensus among all users. A system called <i>Hawk</i> provides privacy-preserving smart contracts. Hawk implements contracts as auctions: each auction receives bids from the users and the auctioneer closes the auction at some point. One challenging problem here is that all bids are visible to the public so, for example, a smart user can wait for others and then submit its bid. In their model, the auctioneer (also called the manager) is assumed to be semi-trusted; it is standard to implement the manager using MPC but for efficiency purposes this is not considered in their model. Hawk supports financial fairness by punishing bad behaviors.</div>
<div class="Unindented">
<h3 style="text-align: justify;">References</h3>
<p class="biblio" style="text-align: justify;"><span class="entry">[<a class="biblioentry" name="biblio-1"/><span class="bib-Sur">AJLTVW</span><span class="bib-YY">12</span>] </span> <span class="bib-authors">Gilad Asharov, Abhishek Jain, Adriana López-Alt, Eran Tromer, Vinod Vaikuntanathan, Daniel Wichs</span>. <span class="bib-title">Multiparty Computation with Low Communication, Computation and Interaction via Threshold FHE</span>. In <i><span class="bib-booktitle">Advances in Cryptology — EUROCRYPT 2012</span></i> . <span class="bib-publisher">Springer Berlin Heidelberg</span>, <span class="bib-year">2012</span>.</p>
<p class="biblio" style="text-align: justify;"><span class="entry">[<a class="biblioentry" name="biblio-2"/><span class="bib-Sur">BGT</span><span class="bib-YY">13</span>] </span> <span class="bib-authors">Elette Boyle, Shafi Goldwasser, Stefano Tessaro</span>. <span class="bib-title">Communication locality in secure multi-party computation: how to run sublinear algorithms in a distributed setting</span>. <i><span class="bib-booktitle">Proceedings of the 10th theory of cryptography conference on Theory of Cryptography</span></i>, pp. <span class="bib-pages">356—376</span>, <span class="bib-year">2013</span>.</p>
<p class="biblio" style="text-align: justify;"><span class="entry">[<a class="biblioentry" name="biblio-3"/><span class="bib-Sur">BGV</span><span class="bib-YY">12</span>] </span> <span class="bib-authors">Zvika Brakerski, Craig Gentry, Vinod Vaikuntanathan</span>. <span class="bib-title">Fully Homomorphic Encryption Without Bootstrapping</span>. <i><span class="bib-booktitle">Proceedings of the 3rd Innovations in Theoretical Computer Science Conference</span></i>, pp. <span class="bib-pages">309—325</span>, <span class="bib-year">2012</span>.</p>
<p class="biblio" style="text-align: justify;"><span class="entry">[<a class="biblioentry" name="biblio-4"/><span class="bib-Sur">CCD</span><span class="bib-YY">88</span>] </span> <span class="bib-authors">David Chaum, Claude Crépeau, Ivan Damgård</span>. <span class="bib-title">Multiparty unconditionally secure protocols</span>. <i><span class="bib-booktitle">Proceedings of the twentieth annual ACM symposium on Theory of computing</span></i>, pp. <span class="bib-pages">11—19</span>, <span class="bib-year">1988</span>.</p>
<p class="biblio" style="text-align: justify;"><span class="entry">[<a class="biblioentry" name="biblio-5"/><span class="bib-Sur">DKMS</span><span class="bib-YY">12</span>] </span> <span class="bib-authors">Varsha Dani, Valerie King, Mahnush Movahedi, Jared Saia</span>. <span class="bib-title">Brief announcement: breaking the <span class="MathJax_Preview">// </span> bit barrier, secure multiparty computation with a static adversary</span>. <i><span class="bib-booktitle">Proceedings of the 2012 ACM symposium on Principles of distributed computing</span></i>, pp. <span class="bib-pages">227—228</span>, <span class="bib-year">2012</span>.</p>
<p class="biblio" style="text-align: justify;"><span class="entry">[<a class="biblioentry" name="biblio-6"/><span class="bib-Sur">DKMS</span><span class="bib-YY">14</span>] </span> <span class="bib-authors">Varsha Dani, Valerie King, Mahnush Movahedi, Jared Saia</span>. <span class="bib-title">Quorums Quicken Queries: Efficient Asynchronous Secure Multiparty Computation</span>. In <i><span class="bib-booktitle">Distributed Computing and Networking</span></i> . <span class="bib-publisher">Springer Berlin Heidelberg</span>, <span class="bib-year">2014</span>.</p>
<p class="biblio" style="text-align: justify;"><span class="entry">[<a class="biblioentry" name="biblio-7"/><span class="bib-Sur">Gen</span><span class="bib-YY">09</span>] </span> <span class="bib-authors">Craig Gentry</span>. <span class="bib-title">Fully homomorphic encryption using ideal lattices</span>. <i><span class="bib-booktitle">Proceedings of the 41st annual ACM symposium on Theory of computing</span></i>, pp. <span class="bib-pages">169—178</span>, <span class="bib-year">2009</span>.</p>
<p class="biblio" style="text-align: justify;"><span class="entry">[<a class="biblioentry" name="biblio-8"/><span class="bib-Sur">BGW</span><span class="bib-YY">88</span>] </span> <span class="bib-authors">Michael Ben-Or, Shafi Goldwasser, Avi Wigderson</span>. <span class="bib-title">Completeness Theorems for Non-Cryptographic Fault-Tolerant Distributed Computing</span>. <i><span class="bib-booktitle">Proceedings of the Twentieth ACM Symposium on the Theory of Computing (STOC)</span></i>, pp. <span class="bib-pages">1—10</span>, <span class="bib-year">1988</span>.</p>
<p class="biblio" style="text-align: justify;"><span class="entry">[<a class="biblioentry" name="biblio-9"/><span class="bib-Sur">CM</span><span class="bib-YY">14</span>] </span> <span class="bib-authors">Michael Clear, Ciarán McGoldrick</span>: <i><span class="bib-title">Multi-Identity and Multi-Key Leveled FHE from Learning with Errors</span></i>. <span class="bib-howpublished">Cryptology ePrint Archive, Report 2014/798</span>, <span class="bib-year">2014</span>.</p>
<p class="biblio" style="text-align: justify;"><span class="entry">[<a class="biblioentry" name="biblio-10"/><span class="bib-Sur">GMW</span><span class="bib-YY">87</span>] </span> <span class="bib-authors">Oded Goldreich, Silvio Micali, Avi Wigderson</span>. <span class="bib-title">How to play ANY mental game</span>. <i><span class="bib-booktitle">Proceedings of the nineteenth annual ACM symposium on Theory of computing</span></i>, pp. <span class="bib-pages">218—229</span>, <span class="bib-year">1987</span>.</p>
<p class="biblio" style="text-align: justify;"><span class="entry">[<a class="biblioentry" name="biblio-11"/><span class="bib-Sur">SZ</span><span class="bib-YY">15</span>] </span> <span class="bib-authors">Jared Saia, Mahdi Zamani</span>. <span class="bib-title">Recent Results in Scalable Multi-Party Computation</span>. In <i><span class="bib-booktitle">SOFSEM 2015: Theory and Practice of Computer Science</span></i> (<span class="bib-editor">Italiano, GiuseppeF. and Margaria-Steffen, Tiziana and Pokorný, Jaroslav and Quisquater, Jean-Jacques and Wattenhofer, Roger</span>, ed.). <span class="bib-publisher">Springer Berlin Heidelberg</span>, <span class="bib-year">2015</span>. URL: <a href="http://dx.doi.org/10.1007/978-3-662-46078-8_3" target="_parent"><span class="bib-url">http://dx.doi.org/10.1007/978-3-662-46078-8_3</span></a>.</p>
<p class="biblio" style="text-align: justify;"><span class="entry">[<a class="biblioentry" name="biblio-12"/><span class="bib-Sur">Yao</span><span class="bib-YY">82</span>] </span> <span class="bib-authors">Andrew C. Yao</span>. <span class="bib-title">Protocols for secure computations</span>. <i><span class="bib-booktitle">Proceedings of the 23rd Annual Symposium on Foundations of Computer Science</span></i>, pp. <span class="bib-pages">160—164</span>, <span class="bib-year">1982</span>.</p>
</div></div></content><updated planet:format="June 20, 2015 06:28 AM">2015-06-20T06:28:16Z</updated><published planet:format="June 20, 2015 06:28 AM">2015-06-20T06:28:16Z</published><category term="Uncategorized"/><category term="secure multiparty computation"/><category term="theory"/><author><name>Jared</name></author><source><id>https://jsaia.wordpress.com</id><logo>https://s0.wp.com/i/buttonw-com.png</logo><link href="https://jsaia.wordpress.com/feed/" rel="self" type="application/atom+xml"/><link href="https://jsaia.wordpress.com" rel="alternate" type="text/html"/><link href="https://jsaia.wordpress.com/osd.xml" rel="search" type="application/opensearchdescription+xml"/><link href="https://jsaia.wordpress.com/?pushpress=hub" rel="hub" type="text/html"/><subtitle>Distributed Algorithms and Security</subtitle><title>Machinations</title><updated planet:format="December 17, 2018 05:29 AM">2018-12-17T05:29:32Z</updated><planet:module>toc</planet:module><planet:format>atom10</planet:format><planet:http_last_modified>Mon, 03 Sep 2018 10:34:51 GMT</planet:http_last_modified><planet:bozo>false</planet:bozo><planet:items_per_page>40</planet:items_per_page><planet:css-id>jared-saia</planet:css-id><planet:face>saia.png</planet:face><planet:name>Jared Saia</planet:name><planet:filters>category.py?cats=theory</planet:filters><planet:http_location>https://jsaia.wordpress.com/feed/</planet:http_location><planet:http_status>301</planet:http_status></source></entry>

