<?xml version="1.0" encoding="utf-8"?><entry xml:lang="en" xmlns="http://www.w3.org/2005/Atom" xmlns:planet="http://planet.intertwingly.net/"><id>http://speedupblogger.wordpress.com/?p=190</id><link href="https://speedupblogger.wordpress.com/2013/03/22/levins-and-schnorrs-optimality-results/" rel="alternate" type="text/html"/><title>Levin’s and Schnorr’s optimality results</title><summary>This week on “Speedup in Computational Complexity” we’re going to learn how to write an optimal solver for SAT. Thanks to Leonid Levin we know that a very partial answer to “Are there familiar computational problems with no best algorithm?” is “Well, computing a satisfying assignment for a boolean formula does have a best algorithm, […]<div class="commentbar"><p/></div></summary><content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>This week on “Speedup in Computational Complexity” we’re going to learn how to write an optimal solver for SAT. Thanks to Leonid Levin we know that a very partial answer to “Are there familiar computational problems with no best algorithm?” is “Well, computing a satisfying assignment for a boolean formula does have a best algorithm, that’s for sure!”. In fact we’ll explore several variations of an idea by Levin all of which provide us with computational problems that each have a best algorithm. One particular variation, by Claus-Peter Schnorr, applies to the class of self-reducible problems.</p>
<p>A word of warning before we start: The below constructions only work in some models of complexity. One of the models in which the results will not apply is the Turing Machine model. I will mention the model requirements as we go along but if you’d like a more detailed discussion of this topic, I refer you to Gurevich’s paper in the references.</p>
<p>Without further ado let’s jump straight into Levin’s neat little trick, performed by a combination of an interpreter and a program enumerator.</p>
<h3>A wonderful sequence of values</h3>
<p>The program that we’ll design in this section takes an input <em>x</em> and runs infinitely, outputting an infinite sequence of values. Our program will output a new number in the sequence every <em>k</em> steps for some constant <em>k</em>. The sequence produced will turn out to be quite a wonderful characterization of <em>x</em> (if you love computational complexity). I’ll use the name <em>iseq(x)</em> for the infinite sequence generated on input <em>x</em>.</p>
<p>To design our program – let’s call it <em>iseqprog</em> – we’ll need two other programs to start from: A program enumerator and an interpreter for the enumerated programs.</p>
<p>The program enumerator, <em>progen</em>, takes as input a pair <em>(i,x)</em> and returns the initial configuration of the program with index <em>i</em> on input <em>x</em>. We’ll expect this operation to be constant-time when either <em>i=0</em> or we already called progen on <em>(i-1,x)</em>. In other words: <em>progen</em> is more like a method of an object (with internal state) which expects to be called with inputs <em>(0,x), (1,x), (2,x),…</em> and is able to process each item in such a call sequence in constant-time.</p>
<p>The interpreter we’ll need cannot be any old interpreter. In these modern times we can expect a certain service level. The interpreter should work like a slot machine in the arcades: Whenever I put in a new coin I continue my game with three more lives. In other words, when I give the interpreter the configuration of program <em>p</em> after <em>t</em> steps on input <em>x</em>, it returns an updated configuration representing the state of program <em>p</em> after <em>t+1</em> steps on input <em>x</em>. It also tells me if <em>p</em> terminated in step <em>t+1</em> and, if so, the return value of <em>p</em> on <em>x</em>. All of this happens in constant time. After all, the interpreter only needs to simulate one single step of <em>p</em> on <em>x</em>.</p>
<p><small>Comment: Almost any old interpreter <em>can</em> be used for Levin’s construction, but the exposition would become more complex.</small></p>
<p>Now I’ll describe the computation of <em>iseqprog</em> on input <em>x</em>. The computation proceeds in <em>rounds</em>, and each round consists of a number of <em>stages</em>. There is an infinite number of rounds. The number of stages in each round is finite but not constant across rounds.</p>
<p>Round 1 has only 1 stage. In this first stage of the first round, <em>iseqprog</em> runs <em>progen</em> on (0,x) and gets back the initial configuration of program 0 on input <em>x</em>. <em>iseqprog</em> then uses the interpreter to interpret just 1 step of program 0 on input <em>x</em>. If program 0 happens to terminate on input <em>x</em> in that first step, <em>iseqprog</em> immediately outputs program 0’s output on input <em>x</em>. Regardless of whether the interpretation of program 0 terminated, <em>iseqprog</em> itself does not terminate; it is on its way to generate an infinite sequence. If the interpretation of program 0 on input <em>x</em> did not terminate in its first step, <em>iseqprog</em> outputs the value 0 before continuing, providing us with a signal that it’s still live and running. This concludes the first (1-stage) round of <em>iseqprog</em>’s computation on <em>x</em>.</p>
<p>The computation continues in an infinite sequence of rounds. In each round, <em>iseqprog</em> calls <em>progen</em> once, adding one new item to the set of program configurations it has accumulated during the previous rounds. Each of these program configurations is interpreted for a number of steps. Every time the interpreter has executed one step of a program <em>i</em>, <em>iseqprog</em> outputs one value. The output value will be 0 or program <em>i</em>’s output on <em>x</em>. Whatever program you may think of, <em>iseqprog</em> will eventually generate its output on <em>x</em> (in between a lot of 0’s and many other values).</p>
<p>If we use this shorthand:</p>
<ul>
<li>“<em>+i</em>”: means “create the initial configuration for program <em>i</em> on input <em>x</em>, then interpret 1 step on that configuration and output one value”</li>
<li>“<em>i</em>” means “interpret 1 more step on the stored configuration for program <em>i</em> and output one value”</li>
</ul>
<p>then we can sum up <em>iseqprog’s</em> first rounds like this:</p>
<p>Round 1: +1<br/>
Round 2: 11+2<br/>
Round 3: 111122+3<br/>
Round 4: 11111111222233+4<br/>
Round 5: 111111111111111122222222333344+5<br/>
Round 6: 32 1’s, 16 2’s, 8 3’s, 4 4’s, 2 5’s, and one +6</p>
<p>I hope it has become clear why <em>iseqprog</em> should be able to generate a new item of <em>iseq</em> every <em>k</em> steps or less for some constant <em>k</em>. Apart from the administrative work of looking up and saving configurations in some table, each step involves at most one call to the program enumerator and one call to the interpreter. These calls were assumed to be constant-time. The administrative work I wlll simply assume to be constant-time as well. <em>iseqprog</em> cannot work as intended in all complexity models; in particular, it doesn’t work for Turing machines.</p>
<p>Now let’s have a look at the sequence <em>iseq(x)</em> itself. The key observation is that although any individual program does not get much attention from <em>iseqprog</em>, it does get a specific percentage of attention that is not dependent on the input <em>x</em>. For instance, program 3 accounts for <img alt="\frac{1}{2^3}=\frac{1}{8}" class="latex" src="https://s0.wp.com/latex.php?latex=%5Cfrac%7B1%7D%7B2%5E3%7D%3D%5Cfrac%7B1%7D%7B8%7D&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="\frac{1}{2^3}=\frac{1}{8}"/> of the interpreter calls made by <em>iseqprog</em> regardless of the input <em>x</em>. The percentage is tied only to the program’s index number according to the program enumerator. From this observation we can derive (proof left to the reader) the salient feature of <em>iseq(x)</em>:</p>
<blockquote><p>If program <em>p</em> outputs <em>y</em> on input <em>x</em> in time <em>t</em>, then <em>y</em> appears in <em>iseq(x)</em> at an index less than <em>ct</em> for <em>c</em> depending only on <em>p</em>.</p></blockquote>
<p>I think this is great! Whatever you want to compute from <em>x</em>, you’ll find it in <em>iseq(x)</em>. What’s more: Your answer appears quite early in the sequence – so early, in fact, that you might as well just run through <em>iseq(x)</em> rather than perform the computation itself! That’s why I decided to call <em>iseq(x)</em> a wonderful sequence.</p>
<p>It’s too good to be true…if it wasn’t for two caveats. First, how do you recognize the value that you’re looking for? And second, what about that constant <em>c</em>? We’ll address these two questions below.</p>
<p><small>Comment: Another caveat is that the above doesn’t apply to all complexity models, in particular to Turing Machines. For most of the common complexity models, I expect that the result will be true if you replace <em>ct</em> by <em>poly(t)</em> where <em>poly</em> is a polynomial depending only on <em>p</em></small></p>
<p>I’ll end this section with a simple specialization of the above that is too nice not to mention:</p>
<blockquote><p>For any function <em>f</em> in <em>P</em>, there is a polynomial <em>p</em> such that <img alt="\min \{ i | {\it iseq(x)}_i = f(x) \} &lt; p(|x|)" class="latex" src="https://s0.wp.com/latex.php?latex=%5Cmin+%5C%7B+i+%7C+%7B%5Cit+iseq%28x%29%7D_i+%3D+f%28x%29+%5C%7D+%3C+p%28%7Cx%7C%29&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="\min \{ i | {\it iseq(x)}_i = f(x) \} &lt; p(|x|)"/></p></blockquote>
<p>And yes, <em>iseqprog</em> generates a new item of <em>iseq(x)</em> in <em>k</em> steps or less for some constant <em>k</em>!</p>
<h3>The optimal solver for SAT</h3>
<p>So what good is all this if you cannot recognize the value you’re looking for. Luckily there are some situations where validating a correct answer is simpler than producing it – yes, I’m thinking about SAT. A satisfying assignment for a boolean formula can be validated in linear time. How can we exploit Levin’s idea to create an optimal solver for SAT?</p>
<p>The simplest answer is to modify the program enumerator. Our new program enumerator, call it <em>progenSAT</em>, wraps each program generated by the original program enumerator in a SAT validator. The computation of <em>progenSAT(i,x)</em> will proceed in two phases like this:</p>
<p>Phase 1: Run <em>progen(i,x)</em> and assign its output value to variable <em>y</em>.<br/>
Phase 2: If <em>y</em> is a satisfying assignment for the boolean formula <em>x</em> then output <em>y</em> else loop infinitely.</p>
<p>If we plug <em>progenSAT</em> into <em>iseqprog</em> we get a new program <em>iseqprogSAT</em> generating a new sequence <em>iseqSAT(x)</em> on input <em>x</em>.</p>
<p>Like the original <em>iseqprog</em>, our new program <em>iseqprogSAT</em> generates a new item every <em>k</em> steps or less for some constant <em>k</em>. I’m assuming that <em>progenSAT</em> also takes constant time to generate each new program configuration. Let us adapt the key observation about <em>iseq(x)</em> to the sequence <em>iseqSAT(x)</em> (once again, I’ll leave the proof to the reader):</p>
<blockquote><p>If program <em>p</em> outputs <em>y</em> on input <em>x</em> in time <em>t</em>, and <em>y</em> is a satisfying assigment for the boolean formula <em>x</em>, then <em>y</em> appears in <em>iseqSAT(x)</em> at an index less than <em>c'(t+|x|)</em> for <em>c’</em> depending only on <em>p</em>.</p></blockquote>
<p>This is remarkable! This means we have a concrete program that is optimal (up to a constant factor) for solving SAT. As a consequence, The question of P vs. NP boils down to a question about this single program’s running time. Define <img alt="\it time^{\neg 0}_p(x)" class="latex" src="https://s0.wp.com/latex.php?latex=%5Cit+time%5E%7B%5Cneg+0%7D_p%28x%29&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="\it time^{\neg 0}_p(x)"/> to be the number of steps program <em>p</em> takes to generate a nonzero value on input <em>x</em>. Now P=NP if and only if there is a polynomial p such that <img alt="\it time^{\neg 0}_{\it iseqprogSAT}(x) &lt; p(|x|)" class="latex" src="https://s0.wp.com/latex.php?latex=%5Cit+time%5E%7B%5Cneg+0%7D_%7B%5Cit+iseqprogSAT%7D%28x%29+%3C+p%28%7Cx%7C%29&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="\it time^{\neg 0}_{\it iseqprogSAT}(x) &lt; p(|x|)"/> for every satisfiable boolean formula <em>x</em>.</p>
<p>In other words, there may be 1 million US$ waiting for you if you’re able to analyze <em>iseqprogSAT</em>‘s running time in detail.</p>
<h3>Notes for the experimentalists</h3>
<p>Now we’ll have a look at the other caveat about Levin’s idea: The constant factor. In the 1990’s, under the supervision of Neil Jones and Stephen Cook, I worked on implementing a program enumerator that would get <em>iseqprog</em> to actually terminate on some toy problems. The problem, of course, is that the constant factors involved are so large you’ll be tempted to never use big-O-notation ever again. Let’s assume that your programs are sequences of <em>k</em> different instructions, and that every sequence of instructions is a valid program. Then the index of a program <em>p</em> is roughly <img alt="k^{|p|}" class="latex" src="https://s0.wp.com/latex.php?latex=k%5E%7B%7Cp%7C%7D&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="k^{|p|}"/>. The constant factor <em>c</em> is then approximately <img alt="2^{k^{|p|}}" class="latex" src="https://s0.wp.com/latex.php?latex=2%5E%7Bk%5E%7B%7Cp%7C%7D%7D&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="2^{k^{|p|}}"/> i.e. doubly exponential in <em>|p|</em>. So to get an answer from <em>iseqprog</em> the useful programs need to be really short.</p>
<p>Actually I found that <em>iseqprog</em> favours short programs so much that it sometimes fails to find program that actually computes the function you’re looking for. In one case, half of the inputs caused one little program, <em>p’</em>, to give the correct result while the other half of the inputs caused another little program, <em>p’’</em>, to give <em>iseqprog</em> its output. A program that tested the input then continued as either <em>p’</em> or <em>p’’</em> was too long to ever get simulated.</p>
<p>It’s actually possible to reduce the constant factor <em>c</em> by a lot, if you’re willing to sacrifice the optimality in asymptotical running time. By revising the strategy used to pick which program to interpret, you wil obtain different tradeoffs between constant factor and asymptotical relation. For instance, consider the variant of <em>iseq(x)</em>, call it <em>iseq_triangle(x)</em> obtained by using the following simple strategy in Levin’s construction:</p>
<p>Round 1: +1<br/>
Round 2: 1+2<br/>
Round 3: 12+3<br/>
Round 4: 123+4<br/>
Round 5: 1234+5</p>
<p>I’ll postulate the following, leaving the proof to the reader: If program <em>p</em> outputs <em>y</em> on input <em>x</em> in time <em>t</em>, then <em>y</em> appears in <em>iseq_triangle(x)</em> at an index less than <img alt="{\it index}_p^2 t^2" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cit+index%7D_p%5E2+t%5E2&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="{\it index}_p^2 t^2"/>.</p>
<p>I once identified a few strategies of this kind but never got around to clarifying in more detail which tradeoffs are possible; or indeed optimal. Could the “triangle” strategy be improved so that the expression above instead would be <img alt="{\it index}_p^2 t \log (t)" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cit+index%7D_p%5E2+t+%5Clog+%28t%29&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="{\it index}_p^2 t \log (t)"/>? I doubt it, but have no proof. It seems like a small but interesting math exercise.</p>
<p>In one variation of <em>iseqprog</em> the programs are actually enumerated in the order of their descriptive complexity. See the references below for details on that.</p>
<h3>Schnorr’s self-reducible predicates</h3>
<p>Claus-Peter Schnorr analyzed applications of Levin’s result in a 1976 ICALP paper. In particular, he was interested in defining a class of predicates that do not allow asymptotical speedup. The contrast to the above results should be noticed: It is an actual predicate, a 2-valued function, that does not have speedup.</p>
<p>I have not been able to prove Schnorr’s main result (the paper’s proof is missing a few details) but I’d like to outline his central idea because it is interesting, and maybe one of the readers can be helpful by providing a proof in the comments of this blog post. I have simplified his definition a bit and refer you to the ICALP paper for the general definition, and for his results on graph isomorphism and speedup in the Turing machine space model.</p>
<p>Let us adapt some notation from <a href="https://speedupblogger.wordpress.com/2012/10/11/a-fundamental-theorem-on-optimality-and-speedup-guest-post-by-amir-ben-amram/" target="_blank" title="the previous blog post by Amir Ben-Amram">the previous blog post by Amir Ben-Amram</a> and define the <em>complexity set</em> <img alt="T_f" class="latex" src="https://s0.wp.com/latex.php?latex=T_f&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="T_f"/> of a function <em>f</em> to be</p>
<blockquote><p><img alt="T_f \stackrel{\it def}= \{ {\it time}_p(x)\ |\ p\ {\it computes}\ f \}" class="latex" src="https://s0.wp.com/latex.php?latex=T_f+%5Cstackrel%7B%5Cit+def%7D%3D+%5C%7B+%7B%5Cit+time%7D_p%28x%29%5C+%7C%5C+p%5C+%7B%5Cit+computes%7D%5C+f+%5C%7D&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="T_f \stackrel{\it def}= \{ {\it time}_p(x)\ |\ p\ {\it computes}\ f \}"/></p></blockquote>
<p>In the remainder of this section, all data will be bit strings, and <em>P</em> will designate a binary predicate, i.e. <img alt="P(x,y) \in \{ 0, 1\}" class="latex" src="https://s0.wp.com/latex.php?latex=P%28x%2Cy%29+%5Cin+%5C%7B+0%2C+1%5C%7D&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="P(x,y) \in \{ 0, 1\}"/>. You may think of SAT as a prime example of the kind of predicates Schnorr analyzes. The decision function for <em>P</em> will be defined by</p>
<blockquote><p><img alt="{\it decide}_P \stackrel{\it def}= \lambda x.\ \exists y: P(x,y)" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cit+decide%7D_P+%5Cstackrel%7B%5Cit+def%7D%3D+%5Clambda+x.%5C+%5Cexists+y%3A+P%28x%2Cy%29&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="{\it decide}_P \stackrel{\it def}= \lambda x.\ \exists y: P(x,y)"/></p></blockquote>
<p>A function <em>w</em> is a witness function for <em>P</em> if and only if</p>
<blockquote><p><img alt="\forall x: P(x, w(x))\ \vee (\forall y: \neg P(x,y)) " class="latex" src="https://s0.wp.com/latex.php?latex=%5Cforall+x%3A+P%28x%2C+w%28x%29%29%5C+%5Cvee+%28%5Cforall+y%3A+%5Cneg+P%28x%2Cy%29%29+&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="\forall x: P(x, w(x))\ \vee (\forall y: \neg P(x,y)) "/></p></blockquote>
<p>The idea behind Schnorr’s result is to consider a class of predicates, <em>P</em> for which there is a tight connection between the complexity set <img alt="T_{{\it decide}_P}" class="latex" src="https://s0.wp.com/latex.php?latex=T_%7B%7B%5Cit+decide%7D_P%7D&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="T_{{\it decide}_P}"/> and the complexity sets of the associated witness functions:</p>
<blockquote><p><img alt="\bigcup \{ T_w\ |\ w\ \textrm{is a witness function for}\ P\}" class="latex" src="https://s0.wp.com/latex.php?latex=%5Cbigcup+%5C%7B+T_w%5C+%7C%5C+w%5C+%5Ctextrm%7Bis+a+witness+function+for%7D%5C+P%5C%7D&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="\bigcup \{ T_w\ |\ w\ \textrm{is a witness function for}\ P\}"/></p></blockquote>
<p>The class in question is the class of (polynomial-time) <em>self-reducible</em> predicates. The criteria for being self-reducible are a bit complex. I will provide a simplified, less general, version here. <em>P</em> is self-reducible if <img alt="P(x,y)" class="latex" src="https://s0.wp.com/latex.php?latex=P%28x%2Cy%29&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="P(x,y)"/> implies <img alt="|x| = |y|" class="latex" src="https://s0.wp.com/latex.php?latex=%7Cx%7C+%3D+%7Cy%7C&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="|x| = |y|"/> and there is a polynomial-time function <img alt="{\it spec}_P" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cit+spec%7D_P&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="{\it spec}_P"/> mapping a pair of (bit string, bit) to a bit string such that</p>
<ol>
<li><img alt="P(x, y_1 \cdots y_n) = P({\it spec}_P(x, y1), y_2 \cdots y_n)" class="latex" src="https://s0.wp.com/latex.php?latex=P%28x%2C+y_1+%5Ccdots+y_n%29+%3D+P%28%7B%5Cit+spec%7D_P%28x%2C+y1%29%2C+y_2+%5Ccdots+y_n%29&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="P(x, y_1 \cdots y_n) = P({\it spec}_P(x, y1), y_2 \cdots y_n)"/></li>
<li><img alt="|{\it spec}_P(x, b)| &lt; |x|" class="latex" src="https://s0.wp.com/latex.php?latex=%7C%7B%5Cit+spec%7D_P%28x%2C+b%29%7C+%3C+%7Cx%7C&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="|{\it spec}_P(x, b)| &lt; |x|"/></li>
</ol>
<p><em>Theorem</em> <small>(Schnorr, 1976, Theorem 2.4, rewritten)</small>: When <em>P</em> is self-reducible, there is an integer <em>k</em> and witness function <em>w</em> for <em>P</em> such that</p>
<blockquote><p><img alt="t \in T_{{\it decide}_P} \Rightarrow \exists t' \in T_w: t' = \mathcal{O}(\lambda x .\ |x|^k t(x))" class="latex" src="https://s0.wp.com/latex.php?latex=t+%5Cin+T_%7B%7B%5Cit+decide%7D_P%7D+%5CRightarrow+%5Cexists+t%27+%5Cin+T_w%3A+t%27+%3D+%5Cmathcal%7BO%7D%28%5Clambda+x+.%5C+%7Cx%7C%5Ek+t%28x%29%29&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="t \in T_{{\it decide}_P} \Rightarrow \exists t' \in T_w: t' = \mathcal{O}(\lambda x .\ |x|^k t(x))"/></p></blockquote>
<p>This theorem is not too hard to prove. To find a witness <em>y</em> for an <em>x</em>, you figure out the bits of <em>y</em> one at a time. It takes <img alt="|x|" class="latex" src="https://s0.wp.com/latex.php?latex=%7Cx%7C&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="|x|"/> rounds in which we test both 0 and 1 as the potential “next bit” of a witness. For the details, I refer you to Schnorr’s paper.</p>
<p>The main theorem of interest to this blog post is Schnorr’s Theorem 2.7. A precise statement of the Theorem requires more technical detail than I’m able to provide here, but its essence is this: For a self-reducible predicate <em>P</em>, the decision problem <img alt="{\it decide}_P" class="latex" src="https://s0.wp.com/latex.php?latex=%7B%5Cit+decide%7D_P&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="{\it decide}_P"/> cannot be sped up by a factor of <img alt="|x|" class="latex" src="https://s0.wp.com/latex.php?latex=%7Cx%7C&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="|x|"/>.</p>
<p>As mentioned above, I’ve not been able to construct a proof based on the ICALP paper, so I’ll leave this a homework to the readers! It certainly seems like all of the necessary constructions have been lined up, but at the place where “standard methods of diagonalization” should be applied I cannot find a satisfactory interpretation of how to combine the big-O notation with the quantification of the variable <em>i</em>. I’d be very interested in hearing from readers that succeeded in proving this Theorem.</p>
<h3>Historical notes and references</h3>
<p><small>All papers mentioned below appear in this blog’s <a href="http://complexityspeedup.wikia.com/wiki/Speedup_in_Computational_Complexity">bibliography</a></small></p>
<p>Leonid Levin introduced the idea in (Levin, 1973). I must admit that I’ve never read the original Russian paper nor its translation in (Trakhtenbrot, 1984), so I rely on (Gurevich, 1988) and (Li and Vitányi, 1993) in the following. The paper presented his “Universal Search Theorem” as a result concerning resource-bounded descriptional complexity. There was no proof in the paper, but he provided the proof in private communications to Gurevich. Levin’s paper uses an advanced strategy for selecting which program to generate in each round. This strategy causes the constant factor associated with a program <em>p</em> to be <img alt="2^{K(p)+1}" class="latex" src="https://s0.wp.com/latex.php?latex=2%5E%7BK%28p%29%2B1%7D&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="2^{K(p)+1}"/> where <em>K(p)</em> is the prefix complexity of <em>p</em> and <img alt="K(p) \leq |p| + 2 \log |p| + k" class="latex" src="https://s0.wp.com/latex.php?latex=K%28p%29+%5Cleq+%7Cp%7C+%2B+2+%5Clog+%7Cp%7C+%2B+k&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="K(p) \leq |p| + 2 \log |p| + k"/> for some constant <em>k</em>. This is explained in Section 7.5 of (Li and Vitányi, 1993).</p>
<p>Schnorr’s paper (Schnorr, 1976) is the earliest English exposition on this topic that I know of, and it seems to be the first application of Levin’s idea to predicates rather than functions with arbitrarily complex values. Gurevich dedicated most of (Gurevich, 1988) to explaining Levin’s idea which seems to have been largely unknown at the time. A major topic in Gurevich’s discussion is the complexity models in which Levin’s idea can be utilized. Amir Ben-Amram wrote a clear and precise exposition on Levin’s idea in Neil Jones’s complexity book (Ben-Amram, 1997), in his guest chapter “The existence of optimal programs”.</p>
<p>There have been some experiments with practical implementation of Levin’s idea. (Li and Vitányi, 1993) mentions work from the 1980’s that combines Levin’s algorithm with machine learning. My own experiments (Christensen, 1999) were done without knowledge of this prior and does not use machine learning but focuses on tailored programming languages and efficient implementations.</p>
<h3>About the author</h3>
<p>I’m a Ph.D. of computer science based in Copenhagen, Denmark. I am currently a Senior System Engineer working on developing highly scalable, distributed systems for Issuu, the leading digital publishing platform (see <a href="http://issuu.com/about" rel="nofollow">http://issuu.com/about</a>). My interest in complexity theory was nurtured by Neil D. Jones and I was brought up on his book “Computability and Complexity From a Programming Perspective”. I recently had the pleasure of co-authoring a paper with Amir Ben-Amran and Jakob G. Simonsen for the Chicago Journal of Theoretical Computer Science, see <a href="http://cjtcs.cs.uchicago.edu/articles/2012/7/contents.html" rel="nofollow">http://cjtcs.cs.uchicago.edu/articles/2012/7/contents.html</a></p></div></content><updated planet:format="March 22, 2013 06:57 PM">2013-03-22T18:57:52Z</updated><published planet:format="March 22, 2013 06:57 PM">2013-03-22T18:57:52Z</published><category term="General"/><author><name>Niels H. Christensen</name></author><source><id>https://speedupblogger.wordpress.com</id><logo>https://s0.wp.com/i/buttonw-com.png</logo><link href="https://speedupblogger.wordpress.com/feed/" rel="self" type="application/atom+xml"/><link href="https://speedupblogger.wordpress.com" rel="alternate" type="text/html"/><link href="https://speedupblogger.wordpress.com/osd.xml" rel="search" type="application/opensearchdescription+xml"/><link href="https://speedupblogger.wordpress.com/?pushpress=hub" rel="hub" type="text/html"/><subtitle>Are there familiar computational problems with no best algorithm?</subtitle><title>Speedup in Computational Complexity</title><updated planet:format="December 17, 2018 05:29 AM">2018-12-17T05:29:57Z</updated><planet:module>toc</planet:module><planet:format>atom10</planet:format><planet:http_last_modified>Mon, 13 Aug 2018 19:00:30 GMT</planet:http_last_modified><planet:bozo>false</planet:bozo><planet:items_per_page>40</planet:items_per_page><planet:css-id>speedup-in-computational-complexity</planet:css-id><planet:face>speedup.png</planet:face><planet:name>Speedup in Computational Complexity</planet:name><planet:http_location>https://speedupblogger.wordpress.com/feed/</planet:http_location><planet:http_status>301</planet:http_status></source></entry>
