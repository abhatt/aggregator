<?xml version="1.0" encoding="utf-8"?><entry xml:lang="en" xmlns="http://www.w3.org/2005/Atom" xmlns:planet="http://planet.intertwingly.net/"><id>http://nanoexplanations.wordpress.com/?p=597</id><link href="https://nanoexplanations.wordpress.com/2011/12/16/polygon-rectangulation-part-3-minimum-length-rectangulation/" rel="alternate" type="text/html"/><title>Polygon rectangulation, part 3: Minimum-length rectangulation</title><summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">In this third (and final) post on polygon rectangulation, I will consider how to find the rectangulation of minimum total length for an orthogonal polygon.  In part one of this short series, we considered rectangulations with a minimum number of … <a href="https://nanoexplanations.wordpress.com/2011/12/16/polygon-rectangulation-part-3-minimum-length-rectangulation/">Continue reading <span class="meta-nav">→</span></a></div><div class="commentbar"><p/></div></summary><content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>In this third (and final) post on polygon rectangulation, I will consider how to find the rectangulation of minimum total length for an orthogonal polygon.  In <a href="http://wp.me/p1mOPD-8y">part one</a> of this short series, we considered rectangulations with a minimum number of rectangles; and, in <a href="http://wp.me/p1mOPD-8Y">part two</a>, we considered rectangulations with a minimum number of “fat” rectangles.  I’ve saved this post for last, because this may be the most useful rectangulation application in VLSI, and this is the rectangulation problem that Ming-Yang Kao and I have applied to self-assembly (though I won’t discuss our application in this post).</p>
<p>The minimum-length rectangulation algorithm appeared in <a href="https://nanoexplanations.files.wordpress.com/2011/03/minimumedgelengthpartitioningofrectilinearpolygons.pdf">Minimum Edge Length Partitioning of Rectilinear Polygons</a>, by Lingas, Pinter, Rivest and Shamir (1982).  The authors proved both a positive and a negative result.  The positive result — which I will focus on today — is a <img alt="O(n^4)" class="latex" src="https://s0.wp.com/latex.php?latex=O%28n%5E4%29&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="O(n^4)"/> dynamic programming algorithm that finds an optimal minimum-length rectangulation for any orthogonal polygon <em>with no interior holes</em>.  The negative result is a proof that, if the input polygon is allowed to have holes, then the problem is NP-complete.  (I discussed the proof of this result in <a href="https://nanoexplanations.wordpress.com/2011/03/05/minimum-edge-length-partitioning-of-rectilinear-polygons/">a previous blog post</a>.)<span id="more-597"/><strong/></p>
<p><strong>Optimal polygon triangulation</strong></p>
<p>The dynamic programming algorithm for polygon rectangulation is similar in structure to a well-known one for polygon triangulation — finding a minimum-length set of nonoverlapping triangles that partitions the input polygon <img alt="P" class="latex" src="https://s0.wp.com/latex.php?latex=P&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="P"/>.  One online source for the triangulation algorithm is <a href="http://www.ics.uci.edu/~eppstein/260/011023/">these lecture notes</a> by David Eppstein.  As far as we know, rectangulation is more complicated to solve than triangulation.  (Among other things, minimum-length triangulation runs in <img alt="O(n^3)" class="latex" src="https://s0.wp.com/latex.php?latex=O%28n%5E3%29&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="O(n^3)"/>, while the Lingas et al. algorithm runs in <img alt="O(n^4)" class="latex" src="https://s0.wp.com/latex.php?latex=O%28n%5E4%29&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="O(n^4)"/>.)  In the words of Lingas et al., “The difficult proof for the rectangular case involves showing how a given polygon can be split in a small number of ways while guaranteeing that the optimal partitioning is consistent with one of these splits.”</p>
<p>In brief, the triangulation problem is “simple,” because finding a triangulation of any input polygon reduces to finding a triangulation of a regular polygon.  (Eppstein’s lecture notes explain why.)  Since we can limit ourselves to input polygons with such nice features, the algorithm analysis is fairly simple.  In the case of rectangulation, there is no known reduction to a simple class of input polygons.  Instead, Lingas et al. show that only certain kinds of subfigures need to be considered, and that an optimal rectangulation of the entire polygon can be built up from optimal rectangulations of those subfigures.  This makes the problem solvable via dynamic programming.  We turn now to the method of rectangulation itself.</p>
<p><strong>Proof of a key lemma</strong></p>
<p>A key lemma in the MELPRP paper is:</p>
<blockquote><p>Lemma 1. In all minimum edge length solutions for any given polygon <img alt="P" class="latex" src="https://s0.wp.com/latex.php?latex=P&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="P"/>, all edges and all internal corners lie on the vertex grid.</p></blockquote>
<p>As defined in the previous blog posts in this series, the vertex grid is the set of all points that lie on both vertical and horizontal lines that pass through a vertex of the input polygon.  This is a very useful fact, since it limits the number of possible subrectangulations we need to evaluate.  However, Lingas et al. assert it without proof.  (Their 11-page paper appeared in a conference, and, to my knowledge, no journal version of the paper has ever appeared.)  Perhaps this lemma is “obvious,” or folklore, but Ming-Yang Kao and I needed (a “slightly stronger” but still equivalent statement) for work we were doing, so we reproved lemma 1.  The proof is short enough that I will reproduce it here.</p>
<blockquote><p>Lemma. Let <img alt="P" class="latex" src="https://s0.wp.com/latex.php?latex=P&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="P"/> be a polygon with all vertices lying on integer coordinates, and let <img alt="R" class="latex" src="https://s0.wp.com/latex.php?latex=R&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="R"/> be a (finite) rectangulation of <img alt="P" class="latex" src="https://s0.wp.com/latex.php?latex=P&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="P"/>.  There is an algorithm that runs in time polynomial in the number of cuts of <img alt="R" class="latex" src="https://s0.wp.com/latex.php?latex=R&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="R"/>, that produces a rectangulation <img alt="R^*" class="latex" src="https://s0.wp.com/latex.php?latex=R%5E%2A&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="R^*"/> of $P$ such that (1) all points of <img alt="R^*" class="latex" src="https://s0.wp.com/latex.php?latex=R%5E%2A&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="R^*"/> lie on integer points, and (2) the total length of <img alt="R^*" class="latex" src="https://s0.wp.com/latex.php?latex=R%5E%2A&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="R^*"/> is at most the total length of <img alt="R" class="latex" src="https://s0.wp.com/latex.php?latex=R&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="R"/>.</p></blockquote>
<p><em>Proof</em>.  If all vertical cuts have integer x-coordinates, and all horizontal cuts have integer y-coordinates, then the rectangulation is an integer rectangulation, and we are done.  Call the cuts that fail to have those properties <em>bad cuts</em>.</p>
<p><em>Claim</em>: For each horizontal bad cut, we can translate it north or south, so that it will either encounter another horizontal bad cut, or reach an integer y-coordinate, without increasing the total perimeter of the rectangulation.</p>
<p><em>Proof of Claim</em>: Let <img alt="h" class="latex" src="https://s0.wp.com/latex.php?latex=h&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="h"/> be the horizontal bad cut we wish to translate.  Let <img alt="v_1,\ldots,v_k" class="latex" src="https://s0.wp.com/latex.php?latex=v_1%2C%5Cldots%2Cv_k&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="v_1,\ldots,v_k"/> be all vertical cuts incident with <img alt="h" class="latex" src="https://s0.wp.com/latex.php?latex=h&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="h"/> from the south.  Let <img alt="v'_1,\ldots,v'_l" class="latex" src="https://s0.wp.com/latex.php?latex=v%27_1%2C%5Cldots%2Cv%27_l&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="v'_1,\ldots,v'_l"/> be all vertical cuts incident with <img alt="h" class="latex" src="https://s0.wp.com/latex.php?latex=h&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="h"/> from the north.  Suppose WLOG that <img alt="k \leq l" class="latex" src="https://s0.wp.com/latex.php?latex=k+%5Cleq+l&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="k \leq l"/>.  We translate <img alt="h" class="latex" src="https://s0.wp.com/latex.php?latex=h&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="h"/> north, extending each <img alt="v_i" class="latex" src="https://s0.wp.com/latex.php?latex=v_i&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="v_i"/> so it remains incident with <img alt="h" class="latex" src="https://s0.wp.com/latex.php?latex=h&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="h"/>, and shortening each <img alt="v'_i" class="latex" src="https://s0.wp.com/latex.php?latex=v%27_i&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="v'_i"/> so it remains incident with <img alt="h" class="latex" src="https://s0.wp.com/latex.php?latex=h&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="h"/> as well.  (If <img alt="k&gt;l" class="latex" src="https://s0.wp.com/latex.php?latex=k%3El&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="k&gt;l"/> then we translate <img alt="h" class="latex" src="https://s0.wp.com/latex.php?latex=h&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="h"/> south, performing the same lengthening and shortening operations, but switching the roles of the <img alt="v_i" class="latex" src="https://s0.wp.com/latex.php?latex=v_i&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="v_i"/> and the <img alt="v'_i" class="latex" src="https://s0.wp.com/latex.php?latex=v%27_i&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="v'_i"/>.)  Since we are shortening the <img alt="v'_i" class="latex" src="https://s0.wp.com/latex.php?latex=v%27_i&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="v'_i"/> by the same length as we are lengthening the <img alt="v_i" class="latex" src="https://s0.wp.com/latex.php?latex=v_i&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="v_i"/>, we do not increase the total perimeter of the rectangulation.  We continue translating <img alt="h" class="latex" src="https://s0.wp.com/latex.php?latex=h&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="h"/> to the north until we encounter either another horizontal cut, or until the <img alt="y" class="latex" src="https://s0.wp.com/latex.php?latex=y&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="y"/>-coordinate of <img alt="h" class="latex" src="https://s0.wp.com/latex.php?latex=h&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="h"/> is an integer.</p>
<p>We run the following algorithm with input <img alt="R" class="latex" src="https://s0.wp.com/latex.php?latex=R&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="R"/>.  Initialize <img alt="R'=R" class="latex" src="https://s0.wp.com/latex.php?latex=R%27%3DR&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="R'=R"/>.  Order the horizontal bad cuts, and order the vertical bad cuts.  Go through the horizontal bad cuts one at a time.  Let <img alt="h" class="latex" src="https://s0.wp.com/latex.php?latex=h&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="h"/> be the horizontal bad cut under consideration.  Translate it, without increasing the perimeter of <img alt="R" class="latex" src="https://s0.wp.com/latex.php?latex=R&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="R"/>, until it has an integer y-coordinate, or until it encounters another horizontal cut. If <img alt="h" class="latex" src="https://s0.wp.com/latex.php?latex=h&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="h"/> encounters another horizontal cut, call it <img alt="h'" class="latex" src="https://s0.wp.com/latex.php?latex=h%27&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="h'"/>, then remove both <img alt="h" class="latex" src="https://s0.wp.com/latex.php?latex=h&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="h"/> and <img alt="h'" class="latex" src="https://s0.wp.com/latex.php?latex=h%27&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="h'"/> from <img alt="R^*" class="latex" src="https://s0.wp.com/latex.php?latex=R%5E%2A&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="R^*"/> (and from the ordering of horizontal cuts of <img alt="R" class="latex" src="https://s0.wp.com/latex.php?latex=R&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="R"/>), and place a new cut <img alt="h''" class="latex" src="https://s0.wp.com/latex.php?latex=h%27%27&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="h''"/> into <img alt="R^*" class="latex" src="https://s0.wp.com/latex.php?latex=R%5E%2A&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="R^*"/>, where the west endpoint of <img alt="h''" class="latex" src="https://s0.wp.com/latex.php?latex=h%27%27&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="h''"/> is (min[x -coordinate of <img alt="h" class="latex" src="https://s0.wp.com/latex.php?latex=h&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="h"/>, x-coordinate of <img alt="h'" class="latex" src="https://s0.wp.com/latex.php?latex=h%27&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="h'"/>], y -coordinate of <img alt="h'" class="latex" src="https://s0.wp.com/latex.php?latex=h%27&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="h'"/>)$, and the east endpoint of <img alt="h''" class="latex" src="https://s0.wp.com/latex.php?latex=h%27%27&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="h''"/> is max[x-coordinate of <img alt="h" class="latex" src="https://s0.wp.com/latex.php?latex=h&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="h"/>, x-coordinate of <img alt="h'" class="latex" src="https://s0.wp.com/latex.php?latex=h%27&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="h'"/>], y -coordinate of <img alt="h'" class="latex" src="https://s0.wp.com/latex.php?latex=h%27&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="h'"/>).  (We name this process <em>absorption</em>, and say that <img alt="h" class="latex" src="https://s0.wp.com/latex.php?latex=h&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="h"/> and <img alt="h'" class="latex" src="https://s0.wp.com/latex.php?latex=h%27&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="h'"/> are <em>absorbed</em> into <img alt="h''" class="latex" src="https://s0.wp.com/latex.php?latex=h%27%27&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="h''"/>.)  If <img alt="h''" class="latex" src="https://s0.wp.com/latex.php?latex=h%27%27&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="h''"/> is at an integer y-coordinate, then we are done with this stage of the loop and we go on to the next horizontal cut in the order.  Otherwise, it may be that we need to translate <img alt="h''" class="latex" src="https://s0.wp.com/latex.php?latex=h%27%27&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="h''"/> either in the same, or the opposite direction as we were translating <img alt="h" class="latex" src="https://s0.wp.com/latex.php?latex=h&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="h"/> previously.  We continue translating in a non-lengthening direction, and absorbing if necessary, until we translate the horizontal cut at an integer y-coordinate.  (There are at most number-of-cuts-many absorptions, so this process terminates efficiently.)  Then we continue with the next horizontal cut in the ordering, until all are considered or removed from the ordering.</p>
<p>Once the bad horizontal cuts are all dealt with as above, we perform the same operations on the ordering of bad vertical cuts, except that we translate east-and-west instead of north-and-south.  By the same arguments as above, in time polynomial in the number of vertical cuts, we place and/or absorb all vertical cuts onto integer x-coordinates without increasing the length of the rectangulation.  Once all cuts have been considered, we have an integer rectangulation <img alt="R^*" class="latex" src="https://s0.wp.com/latex.php?latex=R%5E%2A&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="R^*"/> such that <img alt="p(R') \leq p(R)" class="latex" src="https://s0.wp.com/latex.php?latex=p%28R%27%29+%5Cleq+p%28R%29&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="p(R') \leq p(R)"/>.</p>
<p><strong>Set of subfigures</strong></p>
<p>Given the input polygon <img alt="P" class="latex" src="https://s0.wp.com/latex.php?latex=P&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="P"/>, we will decompose <img alt="P" class="latex" src="https://s0.wp.com/latex.php?latex=P&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="P"/> into subfigures, find the minimum-length rectangulation of each subfigure, then build from that a minimum-length rectangulation of <img alt="P" class="latex" src="https://s0.wp.com/latex.php?latex=P&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="P"/> itself.  Naively, we might expect that we have to consider every subfigure whose vertices lie on the vertex grid of <img alt="P" class="latex" src="https://s0.wp.com/latex.php?latex=P&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="P"/>, and whose boundary is contained within the boundary of <img alt="P" class="latex" src="https://s0.wp.com/latex.php?latex=P&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="P"/>.  With a bit more analysis, it is possible to significantly reduce the set of subfigures that we need to consider.  In the words of Lingas et al, let us call a <em>constructed line</em> “a maximal extension of a partitioning edge to include any sides of the boundary that are contiguous to the edge and go in the same direction.  Two or more aligned edges may be put on the same constructed line, but this is not always the case.”  Lingas et al. provide the following diagram as an example of constructed lines.</p>
<p><a href="https://nanoexplanations.files.wordpress.com/2011/12/constructed_lines.png"><img alt="" class="aligncenter size-full wp-image-613" height="177" src="https://nanoexplanations.files.wordpress.com/2011/12/constructed_lines.png?w=500&amp;h=177" title="constructed_lines" width="500"/></a>We are now able to state the key fact used to limit the size of the set of subfigures that must be considered by the rectangulation algorithm.</p>
<blockquote><p>Fact. It suffices to consider subfigures whose boundary consists of a contiguous piece of the original boundary and at most two constructed lines (and the constructed lines are contiguous).</p></blockquote>
<p><strong>The partitioning rule</strong></p>
<p>Fix a subfigure <img alt="F" class="latex" src="https://s0.wp.com/latex.php?latex=F&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="F"/> that satisfies the previous Fact.  We assume for the moment that we have already considered all (Fact-satisfying) subfigures that are contained inside <img alt="F" class="latex" src="https://s0.wp.com/latex.php?latex=F&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="F"/>.  We choose a <em>candidate point</em> for <img alt="F" class="latex" src="https://s0.wp.com/latex.php?latex=F&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="F"/> by the following method.</p>
<ol>
<li>If <img alt="F" class="latex" src="https://s0.wp.com/latex.php?latex=F&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="F"/> has 0 constructed lines, choose any vertex of <img alt="F" class="latex" src="https://s0.wp.com/latex.php?latex=F&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="F"/>.</li>
<li>If <img alt="F" class="latex" src="https://s0.wp.com/latex.php?latex=F&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="F"/> has 1 constructed line, choose either endpoint of the constructed line.</li>
<li>If <img alt="F" class="latex" src="https://s0.wp.com/latex.php?latex=F&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="F"/> has 2 constructed lines, choose the point where the constructed lines meet.</li>
</ol>
<p>Once we have chosen the candidate point <img alt="p_F" class="latex" src="https://s0.wp.com/latex.php?latex=p_F&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="p_F"/>, we consider each point on the vertex grid to be a possible <em>matching point</em>.  A matching point <img alt="q" class="latex" src="https://s0.wp.com/latex.php?latex=q&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="q"/> is one that defines a rectangle when paired with <img alt="p_F" class="latex" src="https://s0.wp.com/latex.php?latex=p_F&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="p_F"/> — i.e., they are the opposite corners of a rectangle.  There are at most <img alt="O(n^2)" class="latex" src="https://s0.wp.com/latex.php?latex=O%28n%5E2%29&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="O(n^2)"/> possible matching points inside any subfigure, and we only need to consider the points such that the induced rectangle lies entirely within <img alt="F" class="latex" src="https://s0.wp.com/latex.php?latex=F&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="F"/>.  (There are additional optimizations available also.  For example, if <img alt="p_F" class="latex" src="https://s0.wp.com/latex.php?latex=p_F&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="p_F"/> is a concave vertex, then its matching point must have the same x- or y-coordinate at <img alt="p_F" class="latex" src="https://s0.wp.com/latex.php?latex=p_F&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="p_F"/>.  I will leave this optimizaton to one side, though.)</p>
<p>The process so far has produced the following: a set of subfigures; a set of candidate points, one for each subfigure; and a set of matching points for each subfigure, at most <img alt="O(n^2)" class="latex" src="https://s0.wp.com/latex.php?latex=O%28n%5E2%29&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="O(n^2)"/> for each subfigure.  We will now combine these ingredients into a dynamic programming algorithm for minimum-length rectangulation.</p>
<p><strong>Dynamic programming algorithm</strong></p>
<p>Given input polygon <img alt="P" class="latex" src="https://s0.wp.com/latex.php?latex=P&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="P"/>, do the following</p>
<ol>
<li>Produce all subfigures that satisfy the Fact above, and order them by area, from smallest to largest.</li>
<li>Find the candidate point for each figure.</li>
<li>Loop through the figures, in order.</li>
<ol>
<li>When considering figure <img alt="F" class="latex" src="https://s0.wp.com/latex.php?latex=F&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="F"/>, loop through the set of matching points <img alt="m_1,m_2,\ldots" class="latex" src="https://s0.wp.com/latex.php?latex=m_1%2Cm_2%2C%5Cldots&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="m_1,m_2,\ldots"/>.</li>
<ol>
<li>Calculate the length of the rectangulation of <img alt="F" class="latex" src="https://s0.wp.com/latex.php?latex=F&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="F"/> obtained by drawing a rectangle <img alt="R" class="latex" src="https://s0.wp.com/latex.php?latex=R&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="R"/> defined by the candidate point and the matching point <img alt="m_i" class="latex" src="https://s0.wp.com/latex.php?latex=m_i&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="m_i"/>. This can be done quickly because previously in the order of figures we computed the minimum length of the figure <img alt="F'" class="latex" src="https://s0.wp.com/latex.php?latex=F%27&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="F'"/>, which is <img alt="F" class="latex" src="https://s0.wp.com/latex.php?latex=F&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="F"/> minus the rectangle <img alt="R" class="latex" src="https://s0.wp.com/latex.php?latex=R&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="R"/>.</li>
</ol>
<li>Find the minimum over all rectangulations obtained in Step A(i).  Store that as the minimum-length rectangulation for figure <img alt="F" class="latex" src="https://s0.wp.com/latex.php?latex=F&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="F"/>.</li>
</ol>
<li>Halt when we have computed the value of the maxmimum figure, that is, the minimum-length rectangulation of <img alt="P" class="latex" src="https://s0.wp.com/latex.php?latex=P&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="P"/>.</li>
</ol>
<p>Since there <img alt="O(n^2)" class="latex" src="https://s0.wp.com/latex.php?latex=O%28n%5E2%29&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="O(n^2)"/> figures that satisfy the Fact, and, for each figure, there are <img alt="O(n^2)" class="latex" src="https://s0.wp.com/latex.php?latex=O%28n%5E2%29&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="O(n^2)"/> matching points, the total time of the algorithm is <img alt="O(n^4)" class="latex" src="https://s0.wp.com/latex.php?latex=O%28n%5E4%29&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="O(n^4)"/>.</p>
<p><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.jtitle=Proceedings+of+the+20th+Allerton+Conference+on+Communication&amp;rft_id=info%3A%2F&amp;rfr_id=info%3Asid%2Fresearchblogging.org&amp;rft.atitle=Minimum+edge+length+partitioning+of+rectilinear+polygons&amp;rft.issn=&amp;rft.date=1982&amp;rft.volume=&amp;rft.issue=&amp;rft.spage=53&amp;rft.epage=63&amp;rft.artnum=&amp;rft.au=Andrzej+Lingas&amp;rft.au=Ron+Y.+Pinter&amp;rft.au=Ronald+R.+Rivest&amp;rft.au=Adi+Shamir&amp;rfe_dat=bpr3.included=1;bpr3.tags=Computer+Science+%2F+Engineering%2CAlgorithms%2C+Computational+Geometry">Andrzej Lingas, Ron Y. Pinter, Ronald R. Rivest, &amp; Adi Shamir (1982). Minimum edge length partitioning of rectilinear polygons <span style="font-style: italic;">Proceedings of the 20th Allerton Conference on Communication</span>, 53-63</span></p></div></content><updated planet:format="December 16, 2011 03:00 PM">2011-12-16T15:00:42Z</updated><published planet:format="December 16, 2011 03:00 PM">2011-12-16T15:00:42Z</published><category term="Uncategorized"/><category term="computational geometry"/><category term="orthogonal polygon"/><category term="rectangular partitioning"/><category term="rectilinear polygon"/><author><name>Aaron Sterling</name></author><source><id>https://nanoexplanations.wordpress.com</id><logo>https://s0.wp.com/i/buttonw-com.png</logo><link href="https://nanoexplanations.wordpress.com/feed/" rel="self" type="application/atom+xml"/><link href="https://nanoexplanations.wordpress.com" rel="alternate" type="text/html"/><link href="https://nanoexplanations.wordpress.com/osd.xml" rel="search" type="application/opensearchdescription+xml"/><link href="https://nanoexplanations.wordpress.com/?pushpress=hub" rel="hub" type="text/html"/><subtitle>the blog of Aaron Sterling</subtitle><title>Nanoexplanations</title><updated planet:format="December 17, 2018 05:29 AM">2018-12-17T05:29:46Z</updated><planet:module>toc</planet:module><planet:format>atom10</planet:format><planet:http_last_modified>Thu, 12 Apr 2018 01:29:57 GMT</planet:http_last_modified><planet:bozo>false</planet:bozo><planet:items_per_page>40</planet:items_per_page><planet:css-id>aaron-sterling</planet:css-id><planet:face>sterling.jpeg</planet:face><planet:name>Aaron Sterling</planet:name><planet:http_location>https://nanoexplanations.wordpress.com/feed/</planet:http_location><planet:http_status>301</planet:http_status></source></entry>
