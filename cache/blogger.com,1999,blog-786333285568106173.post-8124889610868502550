<?xml version="1.0" encoding="utf-8"?><entry xmlns="http://www.w3.org/2005/Atom" xmlns:planet="http://planet.intertwingly.net/"><id>tag:blogger.com,1999:blog-786333285568106173.post-8124889610868502550</id><link href="http://infoweekly.blogspot.com/feeds/8124889610868502550/comments/default" rel="replies" type="application/atom+xml"/><link href="http://www.blogger.com/comment.g?blogID=786333285568106173&amp;postID=8124889610868502550" rel="replies" type="text/html"/><link href="http://www.blogger.com/feeds/786333285568106173/posts/default/8124889610868502550" rel="edit" type="application/atom+xml"/><link href="http://www.blogger.com/feeds/786333285568106173/posts/default/8124889610868502550" rel="self" type="application/atom+xml"/><link href="http://infoweekly.blogspot.com/2010/09/veb-space-method-4.html" rel="alternate" type="text/html"/><title>vEB Space: Method 4</title><content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">In the previous post I described 3 ways of making the &quot;van Emde Boas data structure&quot; take linear space. I use quotes since there is no unique vEB structure, but rather a family of data structures inspired by the FOCS'75 paper of van Emde Boas. By the way, if you're curious who van Emde Boas is, here is a <a href="http://staff.science.uva.nl/~peter/portretpeter.jpg">portrait</a> found on his webpage.<div><br/><div>In this post, I will describe a 4th method. You'd be excused for asking what the point is, so let me quickly mention that this technique has a great application (1D range reporting, which I will discuss in another post) and it introduces a nice tools you should know.</div></div><div><br/></div><div>Here is a particularly simple variant of vEB, introduced by Willard as the &quot;y-fast tree&quot;. Remember from the last post that the trie representing the set has <i>n</i>-1 branching nodes connected by 2<i>n</i>-1 &quot;active&quot; paths; if we know the lowest branching ancestor of the query, we can find the predecessor in constant time. Willard's approach is to store a hash table with all O(<i>n</i> lg <i>u</i>) active nodes in the trie; for each node, we store a pointer to its lowest branching ancestor. Then, we can binary search for the height of the lowest active ancestor of the query, and follow a pointer to the lowest branching node above. As the trie height is O(lg <i>u</i>), this search takes O(lglg <i>u</i>) look-ups in the hash table.</div><div><br/></div><div>Of course, we can reduce the space from O(<i>n</i> lg <i>u</i>) to O(<i>n</i>)  by bucketing. But let's try something else. We could break the binary search into two phases:</div><div><ol><li>Find <i>v</i>, the lowest active ancestor of the query at some depth of the form i·√<span style="text-decoration: overline;">lg <i>u</i></span> (binary search on <i>i</i>). Say <i>v </i>is on the path <i>u</i>→<i>w </i>(where <i>u</i>, <i>w</i> are branching nodes). If <i>w </i>is not an ancestor of the query, return <i>u.<br/><br/></i></li><li>Otherwise, the lowest branching ancestor of the query is found at some depth in [ i·√<span>lg <i>u</i></span> , (i+1)√<span>lg <i>u</i></span> ]. Binary search to find the lowest active ancestor in this range, and follow a pointer to the lowest active ancestor.</li></ol><div>With this modification, we only need to store O(<i>n</i> √<span>lg <i>u</i></span> ) active nodes in the hash table! To support step 1., we need active nodes at depths i·√<span>lg <i>u</i></span>. To support step 2., we need active nodes whose lowest branching ancestor is only ≤ √<span>lg <i>u</i></span> levels above. All other active nodes can be ignored.</div></div><div><br/></div><div>You could bring the space down to O(<i>n </i>lg<sup>ε</sup><i>u</i>) by breaking the search into more segments. But to bring the space down to linear, we use heavier machinery:</div><div><br/></div><div><b>Retrieval-only dictionaries.</b> Say we want a dictionary (&quot;hash table&quot;) that stores a set of <i>n</i> keys from the universe [<i>u</i>], where each key has <i>k </i>bits of associated data. The dictionary supports two operations:</div><div><ul><li>membership: is <i>x </i>in the set?</li><li>retrieval: assuming <i>x </i>is in the set, return data[<i>x</i>].</li></ul><div>If we want to support both operations, the smallest space we can hope for is log(<i>u</i> choose <i>n</i>) + <i>nk </i>≈<i> n</i>(lg <i>u</i> +<i> k</i>)<i>  </i>bits: the data structure needs to encode the set itself, and the data.</div></div><div><br/></div><div>Somewhat counterintuitively, dictionaries that only support retrieval (without membership queries) are in fact useful. (The definition of such a dictionary is that retrieve(<i>x</i>) may return garbage if <i>x</i> is not in the set.)</div><div><br/></div><div>Retrieval-only dictionaries can be implemented using only O(<i>nk</i>) bits. I will describe this in the next post, but I hope it is believable enough.</div><div><br/></div><div>When is a retrieval-only dictionary helpful? When we can verify answers in some other way. Remember the data structure with space O(<i>n</i> √<span>lg <i>u</i></span> ) from above. We will store branching nodes in a real hash table (there are only <i>n</i>-1 of them).  But observe the following about the O(<i>n</i> √<span>lg <i>u</i></span> ) active nodes that we store:</div><div><ol><li>We only need <i>k</i>=O(lglg <i>u</i>) bits of associated data. Instead of storing a pointer to the lowest branching ancestor, we can just store the height difference (a number between 1 and lg <i>u</i>). This is effectively a pointer: we can compute the branching ancestor by zeroing out so many bits of the node.<br/><br/></li><li>We only need to store them in a retrieval-only dictionary. Say we query some node <i>v </i>and find a height difference δ to the lowest branching ancestor. We can verify whether <i>v </i>was real by looking up the δ-levels-up ancestor of <i>v </i>in the hash table of branching nodes, and checking that <i>v</i> lies on one of the two paths descending from this branching node.</li></ol><div>Therefore, the dictionary of active nodes only requires O(<i>n</i> √<span>lg <i>u</i></span> · lglg <i>u</i>) bits, which is o(<i>n</i>) words of space! This superlinear number of nodes take negligible space compared to the branching nodes.</div></div><div><br/></div></div><div class="commentbar"><p/><span class="commentbutton" href="http://infoweekly.blogspot.com/feeds/8124889610868502550/comments/default"/><a href="http://infoweekly.blogspot.com/feeds/8124889610868502550/comments/default"><img class="commenticon" src="/images/feed-icon.png"/> Subscribe to comments</a><![CDATA[  | ]]><a href="http://www.blogger.com/comment.g?blogID=786333285568106173&amp;postID=8124889610868502550"><img class="commenticon" src="/images/post-icon.png"/> Post a comment</a></div></content><updated planet:format="September 21, 2010 03:11 PM">2010-09-21T15:11:00Z</updated><published planet:format="September 21, 2010 03:11 PM">2010-09-21T15:11:00Z</published><author><name>Mihai</name><email>noreply@blogger.com</email><uri>http://www.blogger.com/profile/11599372864611039927</uri></author><source><id>tag:blogger.com,1999:blog-786333285568106173</id><author><name>Mihai</name><email>noreply@blogger.com</email><uri>http://www.blogger.com/profile/11599372864611039927</uri></author><link href="http://infoweekly.blogspot.com/" rel="alternate" type="text/html"/><link href="http://www.blogger.com/feeds/786333285568106173/posts/default?start-index=26&amp;max-results=25&amp;redirect=false" rel="next" type="application/atom+xml"/><link href="http://feeds.feedburner.com/WebdiariosDeMotocicleta" rel="self" type="application/atom+xml"/><link href="http://pubsubhubbub.appspot.com/" rel="hub" type="text/html"/><subtitle>Informatics Weekly, written by Mihai Pătraşcu.</subtitle><title>WebDiarios de Motocicleta</title><updated planet:format="September 17, 2018 03:40 AM">2018-09-17T03:40:52Z</updated><planet:module>toc</planet:module><planet:format>atom10</planet:format><planet:http_etag>p4aBUs7EfDbSpgYtTTaw3ObCwMk</planet:http_etag><planet:http_last_modified>Sun, 16 Dec 2018 15:48:09 GMT</planet:http_last_modified><planet:bozo>false</planet:bozo><planet:items_per_page>40</planet:items_per_page><planet:css-id>webdiarios-de-motocicleta</planet:css-id><planet:face>mihai.jpg</planet:face><planet:name>WebDiarios de Motocicleta</planet:name><planet:http_status>200</planet:http_status></source></entry>
