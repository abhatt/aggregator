<?xml version="1.0" encoding="utf-8"?><entry xml:lang="en" xmlns="http://www.w3.org/2005/Atom" xmlns:planet="http://planet.intertwingly.net/"><id>http://mittheory.wordpress.com/?p=517</id><link href="https://mittheory.wordpress.com/2014/07/09/so-alice-and-bob-want-to-flip-a-coin-stoc-2014-recaps-part-10/" rel="alternate" type="text/html"/><title>So Alice and Bob want to flip a coin… – STOC 2014 Recaps (Part 10)</title><summary>A major use case for coin flipping (with actual coins) is when you’re with friends, and you have to decide where to eat. This agonizing decision process can be elegantly avoided when randomness is used. But who’s doing the coin flipping? How do you know your friend isn’t secretly choosing which restaurant to go to? […]<div class="commentbar"><p/></div></summary><content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>A major use case for coin flipping (with actual coins) is when you’re with friends, and you have to decide where to eat. This agonizing decision process can be elegantly avoided when randomness is used. But who’s doing the coin flipping? How do you know your friend isn’t secretly choosing which restaurant to go to? Cryptography offers a solution to this, and <a href="http://people.csail.mit.edu/sunoo/">Sunoo</a> will tell us about how this solution is actually equivalent to one way functions!</p>
<hr/>
<p>Sunoo Park on <a href="http://www.cs.tau.ac.il/~iftachh/papers/TightCF/TightCoingFlipping_CR.pdf"><strong>Coin Flipping of Any Constant Bias Implies One-Way Functions</strong></a>, by <a href="http://www.cs.tau.ac.il/~itayberm/">Itay Berman</a>, <a href="http://www.cs.tau.ac.il/~iftachh/">Iftach Haitner</a>, and <a href="http://cs.nyu.edu/~tentes/Homepage.html">Aris Tentes</a></p>
<p>In this post, we look at a fundamental problem that has plagued humankind since long before theoretical computer science: if I don’t trust you and you don’t trust me, how can we make a fair random choice? This problem was once solved in the old-fashioned way of flipping a coin, but theoretical computer science has made quite some advances since.</p>
<p>What are the implications of this? In their recent STOC paper, Berman, Haitner, and Tentes show that the ability for two parties to flip a (reasonably) fair coin means that one-way functions exist. This, in turn has far-reaching cryptographic implications.</p>
<p>A function <img alt="f" class="latex" src="https://s0.wp.com/latex.php?latex=f&amp;bg=ffffff&amp;fg=404040&amp;s=0" title="f"/> is one-way if it is “easy” to compute <img alt="f(x)" class="latex" src="https://s0.wp.com/latex.php?latex=f%28x%29&amp;bg=ffffff&amp;fg=404040&amp;s=0" title="f(x)"/> given any input <img alt="x" class="latex" src="https://s0.wp.com/latex.php?latex=x&amp;bg=ffffff&amp;fg=404040&amp;s=0" title="x"/>, and it is “hard”, given the image <img alt="y" class="latex" src="https://s0.wp.com/latex.php?latex=y&amp;bg=ffffff&amp;fg=404040&amp;s=0" title="y"/> of a random input, to find a preimage <img alt="x'" class="latex" src="https://s0.wp.com/latex.php?latex=x%27&amp;bg=ffffff&amp;fg=404040&amp;s=0" title="x'"/> such that <img alt="f(x')=y" class="latex" src="https://s0.wp.com/latex.php?latex=f%28x%27%29%3Dy&amp;bg=ffffff&amp;fg=404040&amp;s=0" title="f(x')=y"/>. The existence of one-way functions imply a wide range of fundamental cryptographic primitives, including pseudorandom generation, pseudorandom functions, symmetric-key encryption, bit commitments, and digital signatures – and vice versa: the seminal work of Impagliazzo and Luby [1] showed that the existence of cryptography based on complexity-theoretic hardness assumptions – encompassing the all of the aforementioned primitives – implies that one-way functions exist.</p>
<p>About coin-flipping protocols, however, only somewhat more restricted results were known. Coin-flipping has long been a subject of interest in cryptography, since the early work of Blum [2] which described the following problem:</p>
<p style="text-align: center;"><i>“Alice and Bob want to flip a coin by telephone. (They have just divorced, live in different cities, want to decide who gets the car.)”</i></p>
<p>More formally, coin-flipping protocol is a protocol in which two players interact by exchanging messages, which upon completion outputs a single bit interpreted as the outcome of a coin flip. The aim is that the coin should be (close to) unbiased, even if one of the players “cheats” and tries to bias the outcome towards a certain value. We say that a protocol has constant bias if the probability that the outcome is equal to 0 is constant (in a security parameter).</p>
<p>Impagliazzo and Luby’s original paper showed that coin-flipping protocols achieving negligible bias (that is, they are very close to perfect!) imply one-way functions. Subsequently, Maji, Prabhakaran and Sahai [3] proved that coin-flipping protocols with a constant number of rounds (and any non-trivial bias, i.e. <img alt="1/2-o(1)" class="latex" src="https://s0.wp.com/latex.php?latex=1%2F2-o%281%29&amp;bg=ffffff&amp;fg=404040&amp;s=0" title="1/2-o(1)"/>) also imply one-way functions. Yet more recently, Haitner and Omri [4] showed that the same holds for any coin-flipping protocol with a constant bias (namely, a bias of <img alt="\frac{\sqrt{2}-1}{2}-o(1)" class="latex" src="https://s0.wp.com/latex.php?latex=%5Cfrac%7B%5Csqrt%7B2%7D-1%7D%7B2%7D-o%281%29&amp;bg=ffffff&amp;fg=404040&amp;s=0" title="\frac{\sqrt{2}-1}{2}-o(1)"/>). Finally, Berman, Haitner and Tentes proved that coin-flipping of <i>any</i> constant bias implies one-way functions. The remainder of this post will give a flavor of the main ideas behind their proof.</p>
<p>The high-level structure of the argument is as follows: given any coin-flipping protocol <img alt="\Pi=(\mathsf{A},\mathsf{B})" class="latex" src="https://s0.wp.com/latex.php?latex=%5CPi%3D%28%5Cmathsf%7BA%7D%2C%5Cmathsf%7BB%7D%29&amp;bg=ffffff&amp;fg=404040&amp;s=0" title="\Pi=(\mathsf{A},\mathsf{B})"/> between players <img alt="\mathsf{A}" class="latex" src="https://s0.wp.com/latex.php?latex=%5Cmathsf%7BA%7D&amp;bg=ffffff&amp;fg=404040&amp;s=0" title="\mathsf{A}"/> and <img alt="\mathsf{B}" class="latex" src="https://s0.wp.com/latex.php?latex=%5Cmathsf%7BB%7D&amp;bg=ffffff&amp;fg=404040&amp;s=0" title="\mathsf{B}"/>, we first define a (sort of) one-way function, then show that an adversary capable of efficiently inverting that function must be able to achieve a significant bias in <img alt="\Pi" class="latex" src="https://s0.wp.com/latex.php?latex=%5CPi&amp;bg=ffffff&amp;fg=404040&amp;s=0" title="\Pi"/>. The one-way function used is the <i>transcript function</i> which maps the players’ random coinflips to a protocol transcript. The two main neat insights are these:</p>
<ul>
<li>Consider the properties of a coin-flipping protocol when interpreted as a <i>zero-sum game</i> between two players: Alice wins if the outcome is 1, and Bob wins otherwise. If the players play optimally, who wins? It turns out that from the winner, we can deduce that there is a set of protocol transcripts where the outcome is bound to be the winning outcome, <i>no matter what the losing player does</i>: that is, transcripts that are “immune” to the losing player.</li>
<li>A recursive variant of the biasing attack proposed by Haitner and Omri in [4] is proposed. The new attack can be employed by the adversary in order to generate a transcript that lies in the “immune” set with probability close to 1 – so, this adversary (who has access to an inverter for the transcript function) can bias the protocol outcome with high probability.</li>
</ul>
<p>The analysis is rather involved; and there are some fiddly details to resolve, such as how a bounded adversary can simulate the recursive attack efficiently, and ensuring that the inverter will work for the particular query distribution of the adversary. Without going into all those details, the last part of this post describes the optimal recursive attack.</p>
<p>Let <img alt="\mathsf{Inv}" class="latex" src="https://s0.wp.com/latex.php?latex=%5Cmathsf%7BInv%7D&amp;bg=ffffff&amp;fg=404040&amp;s=0" title="\mathsf{Inv}"/> be the function that takes as input a pair <img alt="(\mathbf{t},b)" class="latex" src="https://s0.wp.com/latex.php?latex=%28%5Cmathbf%7Bt%7D%2Cb%29&amp;bg=ffffff&amp;fg=404040&amp;s=0" title="(\mathbf{t},b)"/>, where <img alt="\mathbf{t}" class="latex" src="https://s0.wp.com/latex.php?latex=%5Cmathbf%7Bt%7D&amp;bg=ffffff&amp;fg=404040&amp;s=0" title="\mathbf{t}"/> is a random transcript of a partial (incomplete) honest execution of <img alt="\Pi" class="latex" src="https://s0.wp.com/latex.php?latex=%5CPi&amp;bg=ffffff&amp;fg=404040&amp;s=0" title="\Pi"/> and <img alt="b\in\{0,1\}" class="latex" src="https://s0.wp.com/latex.php?latex=b%5Cin%5C%7B0%2C1%5C%7D&amp;bg=ffffff&amp;fg=404040&amp;s=0" title="b\in\{0,1\}"/>, and outputs a random pair of random coinflips <img alt="(r_1,r_2)" class="latex" src="https://s0.wp.com/latex.php?latex=%28r_1%2Cr_2%29&amp;bg=ffffff&amp;fg=404040&amp;s=0" title="(r_1,r_2)"/> for the players, satisfying the following two conditions: (1) they are consistent with <img alt="\mathbf{t}" class="latex" src="https://s0.wp.com/latex.php?latex=%5Cmathbf%7Bt%7D&amp;bg=ffffff&amp;fg=404040&amp;s=0" title="\mathbf{t}"/>, that is, the coinflips could be plausible next coinflips given the partial transcript <img alt="\mathbf{t}" class="latex" src="https://s0.wp.com/latex.php?latex=%5Cmathbf%7Bt%7D&amp;bg=ffffff&amp;fg=404040&amp;s=0" title="\mathbf{t}"/>; and (2) there exists a continuation of the protocol after <img alt="\mathbf{t}" class="latex" src="https://s0.wp.com/latex.php?latex=%5Cmathbf%7Bt%7D&amp;bg=ffffff&amp;fg=404040&amp;s=0" title="\mathbf{t}"/> and the next-coinflips <img alt="(r_1,r_2)" class="latex" src="https://s0.wp.com/latex.php?latex=%28r_1%2Cr_2%29&amp;bg=ffffff&amp;fg=404040&amp;s=0" title="(r_1,r_2)"/> that leads to the protocol outcome <img alt="b" class="latex" src="https://s0.wp.com/latex.php?latex=b&amp;bg=ffffff&amp;fg=404040&amp;s=0" title="b"/>.</p>
<p>It seems that an effective way for the adversary to use <img alt="\mathsf{Inv}" class="latex" src="https://s0.wp.com/latex.php?latex=%5Cmathsf%7BInv%7D&amp;bg=ffffff&amp;fg=404040&amp;s=0" title="\mathsf{Inv}"/> might be to call <img alt="\mathsf{Inv}(\mathbf{t},1)" class="latex" src="https://s0.wp.com/latex.php?latex=%5Cmathsf%7BInv%7D%28%5Cmathbf%7Bt%7D%2C1%29&amp;bg=ffffff&amp;fg=404040&amp;s=0" title="\mathsf{Inv}(\mathbf{t},1)"/> for each partial transcript <img alt="\mathbf{t}" class="latex" src="https://s0.wp.com/latex.php?latex=%5Cmathbf%7Bt%7D&amp;bg=ffffff&amp;fg=404040&amp;s=0" title="\mathbf{t}"/> at which the relevant player has to make a move, and then to behave according to the outputted coins. We call this strategy the <i>biased-continuation attack</i>, which is the crucial attack underlying the result of [4].</p>
<p>The new paper proposes a <i>recursive biased-continuation attack</i> that adds an additional layer of sophistication. Let <img alt="\mathsf{A}^{(0)}=\mathsf{A}" class="latex" src="https://s0.wp.com/latex.php?latex=%5Cmathsf%7BA%7D%5E%7B%280%29%7D%3D%5Cmathsf%7BA%7D&amp;bg=ffffff&amp;fg=404040&amp;s=0" title="\mathsf{A}^{(0)}=\mathsf{A}"/> be the honest first player’s strategy. Now, define <img alt="\mathsf{A}^{(i)}" class="latex" src="https://s0.wp.com/latex.php?latex=%5Cmathsf%7BA%7D%5E%7B%28i%29%7D&amp;bg=ffffff&amp;fg=404040&amp;s=0" title="\mathsf{A}^{(i)}"/> to be attacker which, rather than sampling a random 1-continuation among all the possible <i>honest</i> continuations of the protocol <img alt="(\mathsf{A},\mathsf{B})" class="latex" src="https://s0.wp.com/latex.php?latex=%28%5Cmathsf%7BA%7D%2C%5Cmathsf%7BB%7D%29&amp;bg=ffffff&amp;fg=404040&amp;s=0" title="(\mathsf{A},\mathsf{B})"/>, instead samples a random 1-continuation among all continuations of <img alt="(\mathsf{A}^{(i-1)},\mathsf{B})" class="latex" src="https://s0.wp.com/latex.php?latex=%28%5Cmathsf%7BA%7D%5E%7B%28i-1%29%7D%2C%5Cmathsf%7BB%7D%29&amp;bg=ffffff&amp;fg=404040&amp;s=0" title="(\mathsf{A}^{(i-1)},\mathsf{B})"/>. Note that <img alt="\mathsf{A}^{(1)}" class="latex" src="https://s0.wp.com/latex.php?latex=%5Cmathsf%7BA%7D%5E%7B%281%29%7D&amp;bg=ffffff&amp;fg=404040&amp;s=0" title="\mathsf{A}^{(1)}"/> is the biased-continuation attacker described above! It turns out that as the number of recursions grows, the probability that the resulting transcript will land in the “immune” set approaches 1 – meaning a successful attack! Naïvely, this attack may require exponential time due to the many recursions required; however, the paper circumvents this by analyzing the probability that the transcript will land in a set which is “almost immune”, and finding that this probability approaches 1 significantly faster.</p>
<p>[1] <a href="http://www.computer.org/csdl/proceedings/focs/1989/1982/00/063483-abs.html">One-Way Functions Are Essential for Complexity Based Cryptography</a>. Impagliazzo, Luby (FOCS 1989).<br/>
[2] <a href="http://dl.acm.org/citation.cfm?id=1008911">Coin Flipping by Telephone: A Protocol for Solving Impossible Problems</a>. Blum (CRYPTO 1981).<br/>
[3] <a href="http://ieeexplore.ieee.org/xpl/login.jsp?tp=&amp;arnumber=5671322&amp;url=http%3A%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D5671322">On the Computational Complexity of Coin Flipping</a>. Maji, Prabhakaran, Sahai (FOCS 2010).<br/>
[4] <a href="http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=6108156">Coin Flipping with Constant Bias Implies One-Way Functions</a>. Haitner, Omri (FOCS 2011).</p></div></content><updated planet:format="July 09, 2014 09:15 PM">2014-07-09T21:15:06Z</updated><published planet:format="July 09, 2014 09:15 PM">2014-07-09T21:15:06Z</published><category term="conferences"/><category term="cryptography"/><category term="STOC"/><author><name>mittheory</name></author><source><id>https://mittheory.wordpress.com</id><logo>https://s0.wp.com/i/buttonw-com.png</logo><link href="https://mittheory.wordpress.com/feed/" rel="self" type="application/atom+xml"/><link href="https://mittheory.wordpress.com" rel="alternate" type="text/html"/><link href="https://mittheory.wordpress.com/osd.xml" rel="search" type="application/opensearchdescription+xml"/><link href="https://mittheory.wordpress.com/?pushpress=hub" rel="hub" type="text/html"/><subtitle>A student blog of MIT CSAIL Theory of Computation Group</subtitle><title>Not so Great Ideas in Theoretical Computer Science</title><updated planet:format="December 17, 2018 05:30 AM">2018-12-17T05:30:11Z</updated><planet:module>toc</planet:module><planet:format>atom10</planet:format><planet:http_last_modified>Thu, 12 Apr 2018 01:31:44 GMT</planet:http_last_modified><planet:bozo>false</planet:bozo><planet:items_per_page>40</planet:items_per_page><planet:css-id>mit-csail-student-blog</planet:css-id><planet:face>csail.png</planet:face><planet:name>MIT CSAIL student blog</planet:name><planet:http_location>https://mittheory.wordpress.com/feed/</planet:http_location><planet:http_status>301</planet:http_status></source></entry>
