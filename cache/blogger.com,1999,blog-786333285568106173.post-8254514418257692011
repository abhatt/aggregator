<?xml version="1.0" encoding="utf-8"?><entry xmlns="http://www.w3.org/2005/Atom" xmlns:planet="http://planet.intertwingly.net/"><id>tag:blogger.com,1999:blog-786333285568106173.post-8254514418257692011</id><link href="http://infoweekly.blogspot.com/feeds/8254514418257692011/comments/default" rel="replies" type="application/atom+xml"/><link href="http://www.blogger.com/comment.g?blogID=786333285568106173&amp;postID=8254514418257692011" rel="replies" type="text/html"/><link href="http://www.blogger.com/feeds/786333285568106173/posts/default/8254514418257692011" rel="edit" type="application/atom+xml"/><link href="http://www.blogger.com/feeds/786333285568106173/posts/default/8254514418257692011" rel="self" type="application/atom+xml"/><link href="http://infoweekly.blogspot.com/2010/08/taxonomy-of-range-query-problems.html" rel="alternate" type="text/html"/><title>A taxonomy of range query problems</title><content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><div>In this post, I will try to enumerate the range query problems that I know about. Let me know if I'm missing anything.</div><div><br/></div><div><b>The query. </b>Say you have <i>n</i> points in the plane, and you query for the points in an axis-parallel rectangle. What could we mean by &quot;query&quot;?</div><div><ul><li><i>existential range queries</i>: Is there any point in the rectangle?</li><li><i>counting queries</i>: How many points are there in the rectangle?</li><li><i>reporting queries</i>: List the points in the rectangle. Unlike the previous cases, the query time is now broken into two components: it is usually given as f(n) + k*g(n), where k is the number of output points.</li></ul><div>Now let's assume the points have some number associated to them (a weight or a priority). Then one could ask the following natural queries:</div></div><div><ul><li><i>weighted counting</i>: What is the total weight of the points inside?</li><li><i>range min (max) query</i></li><li><i>range median query</i>. (Possible generalizations: selection or quantiles.)</li><li><i>top-k reporting: </i>Report just the top <i>k</i> guys, by priority (for <i>k</i> given). One may demand the output to be sorted. More stringently, one may ask the query algorithm to enumerate points sorted by priority, in time g(n) per point, until the user says &quot;stop.&quot;</li></ul><div>The number associated to a point can also be a &quot;color&quot;. For instance, points could represent Irish pubs / Belgian bars / etc, and we may only want one point of each type in our output. Then the queries become:</div></div><div><ul><li><i>colored counting: </i>How many distinct colors are in the rectangle?</li><li><i>colored reporting</i>: List the distinct colors in the rectangle (possibly with one example point from each color).</li><li><i>top-k colored reporting</i>: If the colors are sorted by priorities (e.g. I prefer points of color 1 over points of color 2), one can then ask for the top-k distinct colors inside the rectangle.</li></ul></div><div><br/></div><div><b>Dynamism.</b> The problem could be:</div><div><ul><li><i>static</i>: Preprocess the point set and then answer queries.</li><li><i>dynamic</i>: Insert and delete from the point set.</li><li><i>incremental</i> / <i>decremental</i>: We only insert or delete.</li><li><i>offline</i>: The sequence of operations is known in advance. This is enough for many applications to algorithms.</li><li><i>parametric</i> / <i>kinetic</i>. I confess ignorance with respect to these. </li></ul><div><b><br/></b></div><div><b>Orthogonal range queries. </b>The setting from above works in any number of dimensions <i>d</i>≥1: the data set consists of  <i>n</i> points in <i>d</i>-dimensional space and the query is a box [a<sub>1</sub>, b<sub>1</sub>]×···×[a<sub><i>d</i></sub>, b<sub><i>d</i></sub>]. This setup is usually called &quot;orthogonal range queries&quot;.</div></div><div><br/></div><div>We can consider the following important restrictions on the query:</div><div><ul><li><i>dominance queries</i>: the box is [0, b<sub>1</sub>]×···×[0, b<sub><i>d</i></sub>]. In other words, we are asking for the points dominated, coordinate-wise, by a point (b<sub>1</sub>, ..., b<sub><i>d</i></sub>).<br/><br/></li><li><i>k</i>-<i>sided queries</i>: exactly 2<i>d</i>-<i>k</i> values in (a<sub>1</sub>, a<sub>2</sub>, ..., a<sub><i>d</i></sub>) are zero. For instance, a 3-sided query in 2D is a rectangle with one side on the <i>x</i> axis. Dominance queries are the special case of <i>d</i>-sided queries.</li></ul></div><div><b><br/></b></div><div><b>The universe. </b>The coordinates of the points and queries can come from the following sets:</div><div><ul><li>general universe. In the standard RAM model, we assume that the coordinates are integers that fit in a machine word.<br/><br/></li><li><i>rank space</i>: the coordinates are from {1, 2, ..., <i>n</i>}. One can reduce any static problem to rank space by running 2<i>d</i> predecessor queries. Most problems can be shown to be at least as hard as predecessor search, so their complexity is precisely: &quot;optimal cost of predecessor search&quot; + &quot;optimal cost for the problem in rank space&quot;. In other words, for most problems it is sufficient to solve them in rank space.<br/><br/></li><li>dense universe: the points are exactly the points of the grid [1, <i>n</i><sub>1</sub>]×···×[1, <i>n</i><sub><i>d</i></sub>] where <i>n</i><sub>1</sub><i>n</i><sub>2</sub>···<i>n</i><sub><i>d </i></sub>= <i>n</i>. In 1D this is the same as rank space, but in 2 or more dimensions the problems are very different. (To my knowledgeable readers: Is there a standard name for this case? For counting queries people call this &quot;the partial sums problem&quot;, but how about e.g. min queries?)</li></ul><div>For dynamic problems, the &quot;rank space&quot; changes when a new coordinate value is inserted. Thus, a rank-space solution must support a &quot;insert value&quot; operation that increments all coordinate values after a given one, creating space for a newly inserted point. (I have heard the term &quot;<i>list space</i>&quot; for this. Should we just use &quot;rank space&quot;?)</div><div><br/></div></div><div><br/></div><div><b>Stabbing. </b>So far, our data set consisted of points and the queries asked for points in a given rectangle. Conversely, one can consider a data set of rectangles; the query is a point and asks about the rectangles containing that point (&quot;stabbed&quot; by it). This problem is important, among others, in routing: we can have rules for packets coming from some range of IP addresses and going to some other range of IP addresses.</div><div><br/></div><div>The notion of rank space, and all query combinations still make sense. For instance, <i>interval max stabbing</i> is the following problem: given a set of interval (in 1D) with priorities, return the interval of highest priority stabbed by a query point.</div><div><br/></div><div>Note that the rectangles in the input can intersect! If we ask that the rectangles be disjoint, or more stringently, be a partition of the space, we obtain the <i>point location problem.</i></div><div><b><br/></b></div><div><b><br/></b></div><div><b>Rectangle-rectangle queries. </b>So far we looked at containment relations between rectangles and points. More generally, the data set can consist of rectangles, and the query can also be a rectangle. Then one can ask:</div><div><ul><li><i>intersection queries</i>: analyze the set of input rectangles that intersect the query rectangle.</li><li><i>containment queries</i>: analyze the set of rectangles that contain / are-contained-by the query.</li></ul></div><div>Two important special cases arise when the rectangles degenerate to line segments:</div><div><ul><li><i>orthogonal segment intersection</i>: Given a set of horizontal segments, find the ones that intersect a vertical query segment.<br/><br/></li><li><i>orthogonal ray shooting</i>: Given a set of horizontal segments, find the lowest one immediately above a query point. In other words, consider a vertical ray leaving from the point and find the first segment it intersects. (This is the min segment intersection query, where the priority of each horizontal segment is its <i>y</i> coordinate.)</li></ul></div><div><b><br/></b></div><div><b>More complex geometry. </b>Of course, our ranges need not be orthogonal. One can consider:</div><div><ul><li>balls</li><li>arbitrary lines</li><li>half spaces</li><li>simplices (e.g 2D triangles).</li></ul></div><div>In non-orthogonal geometry, the concept of rank space disappears. However, most other combinations are possible. For instance, one could ask about the points in a query range; the ranges stabbed by a query point; the ranges intersecting a query range; the first rangeintersected by a ray; etc. We can ask existential, counting, or reporting questions, on ranges that can have weights or priorities.</div><div><br/></div></div><div class="commentbar"><p/><span class="commentbutton" href="http://infoweekly.blogspot.com/feeds/8254514418257692011/comments/default"/><a href="http://infoweekly.blogspot.com/feeds/8254514418257692011/comments/default"><img class="commenticon" src="/images/feed-icon.png"/> Subscribe to comments</a><![CDATA[  | ]]><a href="http://www.blogger.com/comment.g?blogID=786333285568106173&amp;postID=8254514418257692011"><img class="commenticon" src="/images/post-icon.png"/> Post a comment</a></div></content><updated planet:format="August 04, 2010 05:12 PM">2010-08-04T17:12:00Z</updated><published planet:format="August 04, 2010 05:12 PM">2010-08-04T17:12:00Z</published><author><name>Mihai</name><email>noreply@blogger.com</email><uri>http://www.blogger.com/profile/11599372864611039927</uri></author><source><id>tag:blogger.com,1999:blog-786333285568106173</id><author><name>Mihai</name><email>noreply@blogger.com</email><uri>http://www.blogger.com/profile/11599372864611039927</uri></author><link href="http://infoweekly.blogspot.com/" rel="alternate" type="text/html"/><link href="http://www.blogger.com/feeds/786333285568106173/posts/default?start-index=26&amp;max-results=25&amp;redirect=false" rel="next" type="application/atom+xml"/><link href="http://feeds.feedburner.com/WebdiariosDeMotocicleta" rel="self" type="application/atom+xml"/><link href="http://pubsubhubbub.appspot.com/" rel="hub" type="text/html"/><subtitle>Informatics Weekly, written by Mihai Pătraşcu.</subtitle><title>WebDiarios de Motocicleta</title><updated planet:format="September 17, 2018 03:40 AM">2018-09-17T03:40:52Z</updated><planet:module>toc</planet:module><planet:format>atom10</planet:format><planet:http_etag>p4aBUs7EfDbSpgYtTTaw3ObCwMk</planet:http_etag><planet:http_last_modified>Sun, 16 Dec 2018 15:48:09 GMT</planet:http_last_modified><planet:bozo>false</planet:bozo><planet:items_per_page>40</planet:items_per_page><planet:css-id>webdiarios-de-motocicleta</planet:css-id><planet:face>mihai.jpg</planet:face><planet:name>WebDiarios de Motocicleta</planet:name><planet:http_status>200</planet:http_status></source></entry>
