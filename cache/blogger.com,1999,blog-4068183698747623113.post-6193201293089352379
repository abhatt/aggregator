<?xml version="1.0" encoding="utf-8"?><entry xmlns="http://www.w3.org/2005/Atom" xmlns:planet="http://planet.intertwingly.net/"><id>tag:blogger.com,1999:blog-4068183698747623113.post-6193201293089352379</id><link href="http://teachingintrotocs.blogspot.com/feeds/6193201293089352379/comments/default" rel="replies" type="application/atom+xml"/><link href="http://teachingintrotocs.blogspot.com/2012/02/year-of-tsp.html#comment-form" rel="replies" type="text/html"/><link href="http://www.blogger.com/feeds/4068183698747623113/posts/default/6193201293089352379" rel="edit" type="application/atom+xml"/><link href="http://www.blogger.com/feeds/4068183698747623113/posts/default/6193201293089352379" rel="self" type="application/atom+xml"/><link href="http://teachingintrotocs.blogspot.com/2012/02/year-of-tsp.html" rel="alternate" type="text/html"/><title>The year of the TSP</title><content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">When I was at ITCS, last month, I talked to Huyng-Chan An who told me about his recent work with David Shmoys and Bobby Kleinberg (to appear in STOC 2012).<br/> <br/>They study the s-t path variant of TSP, that asks for the shortest path going from a pre-specified start vertex s to a pre-specified end vertex t while visiting all other vertices along the way.  What is the motivation for this problem? Well, imagine that you are a postman delivering letters. You pick up letters at the post office, deliver them, and when you're done, you go home: you have just built an s-t path, with the post office as s and your home as t. Or, imagine that your building is on fire, it is early in the morning, and the fire alarm is not working. You want to leave your office, visit all offices in the building as quickly as possible to tell anyone who might be there already that they must leave, and then you want to get out. No way you want to go back to your starting point in the end!<br/><br/>Christofides' algorithm, adapted to that variant, is not a 3/2 but a 5/3 approximation in the metric setting. An, Kleinberg and Shmoys have a very simple algorithm that improves the 5/3=1.66… to 1.61… The funny thing is that I did not know about the 5/3 approximation until An told me that they had improved upon that twenty years old bound! For that reason, I am hesitant to call it a breakthrough, and also because it comes along with several recent papers making progress on special cases of TSP. As a friend recently suggested, this is shaping up as &quot;the year of the TSP&quot;!  But I looked at their result in more detail, and it is a clean, more or less self-contained, clever application of modern techniques. That's what makes it appealing. <br/><br/>What's the algorithm? <br/><br/>Nothing special, really:<br/>(1). Solve the natural variant of the Held-Karp linear programming lower bound for TSP<br/>(2). Express the solution as a convex combination of spanning trees (that's known to be possible by polyhedral combinatorics)<br/>(3). Pick a random such tree T* according to the distribution given in (2), and <br/>(4). use it in an execution of the natural variant of the Christofides heuristic.<br/>The fact that it is &quot;nothing special&quot;, in my view, is a good thing. It means that it can be implemented at little additional cost. (The difficulty is in the analysis.) <br/><br/>What's the &quot;natural variant&quot; of the Held-Karp constraints? Some constraints are different: every s-t cut must be crossed by a minimum of just one edge (instead of a minimum of two edges, in the usual version). <br/><br/>What's the &quot;natural variant&quot; of the Christofides heuristic? Instead of finding a perfect matching of the odd degree vertices of T*, it finds a perfect matching (T-join) of the &quot;off-degree&quot; vertices of T*, that is, the vertices whose degree has the wrong parity: the difference with the usual setup is that now, vertex s has the wrong parity if its degree in T* is even, and similarly vertex t has the wrong parity if its degree in T* is even. <br/><br/>So, that's the algorithm.<br/><br/>What's the analysis? <br/><br/>First, they present an elegant proof of the 5/3 approximation result, then modify it. Because of that, we first have to understand why the algorithm is a 5/3 approximation. The tree T* from step 3 has expected cost bounded by OPT, so the sole focus is on bounding the cost of the T-join.  That is achieved by bounding the value of a particular  fractional T-join. What's a fractional T-join? It's a feasible solution to the following LP:<br/>* for every edge e, variable y(e) must be between 0 and 1<br/>* for every proper cut (S,V-S), if S contains an odd number of &quot;off-degree&quot; vertices, then at least one edge crosses the cut - or in other words, fractionally, the sum, over every edge e crossing the cut, of y(e), must be at least 1.<br/>As it happens, that polytope has integer vertices, so the optimal (integer) T-join is also an optimal fractional T-join, and so the cost of the T-join built by the algorithm in step (4) can be bounded by the cost of any fractional T-join. The proof exploits this freedom to carefully choose a particular fractional T-join whose expected cost is less than 2/3 OPT. How can it prove that the cost is less than 2/3 OPT? By proving that it's less than the 2/3 times the Held-Karp lower bound. So, the proof has now neatly moved to the realm of polyhedral analysis, and the rest is now a matter of manipulating vectors y=(y(e)).<br/><br/>The 5/3 result is proved by choosing, for our fractional T-join, a scaled version of an average of two solutions that each achieve the Held-Karp lower bound, namely: the fractional solution x* obtained in step (1), and the tree T* obtained in step (3). Indeed, x* satisfies all the fractional T-join constraints, but in addition, observe that there are some constraints where it has slack: for some cuts, the T-join constraint requires a weight of 1 across the cut, but x* guarantees a weight of 2 across the cut. The tree T* also satisfies all the fractional T-join constraints, but in addition, observe that there are also some constraints where it has some slack: for some cuts, the T-join constraint requires a weight of 1 across the cut, but T* guarantees a weight of 2  across the cut. Really? Well, yes: if S separates s from t and contains an odd number of &quot;off-degree&quot; vertices, then a straightforward counting argument shows that at last 2 edges of the tree must come out of S. Now, the funny thing is that T* has slack precisely for every constraint where x* does <i>not</i> have slack! So if we take the average of x* and of T*, for each constraint of the fractional T-join, we'll have (1+2)/2=3/2 edges crossing at least, and so, if we scale by 2/3, it's still feasible! That shows that y=(2/3)(x*/2+ T*/2) is a feasible fractional T-join. To recap, its cost is at most 2/3 times the average cost of x* and of T*, which is at most 2/3 OPT.  The T-join built in step (4) has cost less than that, and that's how they get a 1+2/3=5/3 approximation.<br/><br/>How do they improve on this analysis? By fiddling with the factors cleverly. To get a fractional T-join with cost slightly better than 2/3, instead of x*/3+T*/3, they pick y=(1/3-2c)x* + (1/3+c)T*+(correction vector for the fractional T-join constraints that are now violated), and hope that the cost of the correction vector is less than c OPT. Realizing that hope requires a careful analysis of the violated constraints. They observe that<br/>* even if constraints are violated, they're <i>not violated by much</i>: the sum across the cut is still at least 1-O( c). The deficiency is O( c).<br/>* given that T* is drawn at random in step (2), those cuts are <i>rare</i>: an elementary argument uses Markov's inequality to show that their probability is O( c).<br/>So the correction vector z will simply have z(e)=deficiency times Pr(e in cut where the constraint is violated) times x*(e)=O(c^2)x*(e).<br/>Then the cost of the fractional T-join y is (2/3 - c + O(c^2))OPT, which is less than 2/3 for c  small enough constant.<br/><br/>There's an additional technicality: the above reasoning is buggy when the violated constraints correspond to non-disjoint cuts, but they show that they can make the cuts disjoint up to   introducing another small factor 1-O( c).  And with that, they beat the 5/3 approximation.  (There's more to the analysis to refine it and get further improvements, but that's beyond my attention span...)<br/><br/>What's the take-home message from that proof? Perhaps, it is a hymn to the power and flexibility of LP feasibility. The technique seems general. They pushed it through for the s-t path TSP problem, but why not use it for other problems, whenever there's an integer polytope behind the scenes?</div><div class="commentbar"><p/><span class="commentbutton" href="http://teachingintrotocs.blogspot.com/feeds/6193201293089352379/comments/default"/><a href="http://teachingintrotocs.blogspot.com/feeds/6193201293089352379/comments/default"><img class="commenticon" src="/images/feed-icon.png"/> Subscribe to comments</a><![CDATA[  | ]]><a href="http://teachingintrotocs.blogspot.com/2012/02/year-of-tsp.html#comment-form"><img class="commenticon" src="/images/post-icon.png"/> Post a comment</a></div></content><updated planet:format="February 15, 2012 05:16 PM">2012-02-15T17:16:00Z</updated><published planet:format="February 15, 2012 05:16 PM">2012-02-15T17:16:00Z</published><category scheme="http://www.blogger.com/atom/ns#" term="TCS"/><author><name>Claire Mathieu</name><email>noreply@blogger.com</email><uri>http://www.blogger.com/profile/10957755706440077623</uri></author><source><id>tag:blogger.com,1999:blog-4068183698747623113</id><category term="TCS"/><category term="Oops"/><category term="technology"/><author><name>Claire Mathieu</name><email>noreply@blogger.com</email><uri>http://www.blogger.com/profile/10957755706440077623</uri></author><link href="http://teachingintrotocs.blogspot.com/feeds/posts/default" rel="http://schemas.google.com/g/2005#feed" type="application/atom+xml"/><link href="http://www.blogger.com/feeds/4068183698747623113/posts/default/-/TCS" rel="self" type="application/atom+xml"/><link href="http://teachingintrotocs.blogspot.com/search/label/TCS" rel="alternate" type="text/html"/><link href="http://pubsubhubbub.appspot.com/" rel="hub" type="text/html"/><title>A CS Professor's blog</title><updated planet:format="August 31, 2018 11:03 AM">2018-08-31T11:03:02Z</updated><planet:module>toc</planet:module><planet:format>atom10</planet:format><planet:http_etag>W/&quot;8089cd57e1113cac488458ecc6b57d2f5d63c2f2cb0051d1de6e12d23ed12d82&quot;</planet:http_etag><planet:http_last_modified>Fri, 31 Aug 2018 11:03:02 GMT</planet:http_last_modified><planet:bozo>false</planet:bozo><planet:items_per_page>40</planet:items_per_page><planet:css-id>claire-mathieu</planet:css-id><planet:face>mathieu.jpeg</planet:face><planet:name>Claire Mathieu</planet:name><planet:filters>category.py?cats=tcs</planet:filters><planet:http_status>200</planet:http_status></source></entry>

