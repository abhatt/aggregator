<?xml version="1.0" encoding="utf-8"?><entry xmlns="http://www.w3.org/2005/Atom" xmlns:planet="http://planet.intertwingly.net/"><id>tag:blogger.com,1999:blog-786333285568106173.post-2947554534039774592</id><link href="http://infoweekly.blogspot.com/feeds/2947554534039774592/comments/default" rel="replies" type="application/atom+xml"/><link href="http://www.blogger.com/comment.g?blogID=786333285568106173&amp;postID=2947554534039774592" rel="replies" type="text/html"/><link href="http://www.blogger.com/feeds/786333285568106173/posts/default/2947554534039774592" rel="edit" type="application/atom+xml"/><link href="http://www.blogger.com/feeds/786333285568106173/posts/default/2947554534039774592" rel="self" type="application/atom+xml"/><link href="http://infoweekly.blogspot.com/2010/09/retrieval-only-dictionaries.html" rel="alternate" type="text/html"/><title>Retrieval-Only Dictionaries</title><content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">We saw two <a href="http://infoweekly.blogspot.com/2010/09/static-1d-range-reporting.html">cool</a> <a href="http://infoweekly.blogspot.com/2010/09/veb-space-method-4.html">applications</a> of dictionaries without membership; now it's time to construct them. Remember that we are given a set <i>S</i>, where each element <i>x</i>∈<i>S</i> has some associated data[<i>x</i>], a <i>k</i>-bit value. We want a data structure of O(<i>nk</i>) bits which retrieves data[<i>x</i>] for any <i>x</i>∈<i>S</i> and may return garbage when queried for <i>x</i>∉<i>S</i>.<div><br/></div><div>A conceptually simple solution is the &quot;Bloomier filter&quot; of [Chazelle, Kilian, Rubinfeld, Tal SODA'04]. This is based on the power of two choices, so you should first go back and review my <a href="http://infoweekly.blogspot.com/2010/02/cuckoo-hashing.html">old post</a> giving an encoding analysis of cuckoo hashing.</div><div><br/></div><div>Standard cuckoo hashing has two arrays A[1..2<i>n</i>], B[1..2<i>n</i>] storing keys, and places a key either at A[<i>h</i>(<i>x</i>)] or B[<i>g</i>(<i>x</i>)]. Instead of this, our arrays <i>A</i> and <i>B</i> will store <i>k</i>-bit values (O(<i>nk</i>) bits in total), and the query retrieve-data(<i>x</i>) will return A[<i>h</i>(<i>x</i>)] <b>xor</b> B[<i>g</i>(<i>x</i>)].</div><div><br/></div><div>The question is whether we can set up the values in A and B such that any query<i> </i><i>x</i>∈<i>S</i> returns data[<i>x</i>] correctly. This is a question about the feasibility of a linear system with <i>n</i> equations (one per key) and 4<i>n</i> variables (one per array entry).</div><div><br/></div><div>Consider a connected component in the bipartite graph induced by cuckoo hashing. If this component is acyclic, we can fix A and B easily. Take an arbitrary node and make it &quot;zero&quot;; then explore the tree by DFS (or BFS).  Each new node (an entry in A or B) has a forced value, since the edge advancing to it must return some data[<i>x</i>] and the parent node has been fixed already. As the component is acyclic, there is only one constraint on every new node, so there are no conflicts.</div><div><br/></div><div>On the other hand, if a component has a cycle, we are out of luck. Remark that if we <b>xor </b>all cycle nodes by some Δ, the answers are unchanged, since the Δ's cancel out on each edge. So a cycle of length <i>k</i> must output <i>k </i>independent data values, but has only <i>k</i>-1 degrees of freedom. </div><div><br/></div><div>Fortunately, one can prove the following about the cuckoo hashing graph:</div><div><ul><li>the graph is acyclic with some constant probability. Thus, the construction algorithm can rehash until it finds an acyclic graph, taking O(<i>n</i>) time in expectation.<br/><br/></li><li>the total length of all cycles is O(lg <i>n</i>) with high probability. Thus we can make the graph acyclic by storing O(lg <i>n</i>) special elements in a stash. This gives construction time O(<i>n</i>) w.h.p., but the query algorithm is slightly more complicated (for instance, it can handle the stash by a small hash table on the side).</li></ul></div><div>These statements fall out naturally from the encoding analysis of cuckoo hashing. A cycle of length <i>k </i>allows a saving of roughly <i>k</i> bits in the encoding: we can write the <i>k</i> keys on the cycle (<i>k</i>lg <i>n</i> bits) plus the <i>k</i> hash codes (<i>k</i>lg(2<i>n</i>) bits) instead of 2<i>k</i> hash codes (2<i>k</i>lg(2<i>n</i>) bits).</div><div><br/></div><div><b>Further remarks.</b> Above, I ignored the space to store the hash functions <i>h</i> and <i>g</i>. You have to believe me that there exist families of hash functions representable in O(<i>n</i><sup>ε</sup>) space, which can be evaluated in constant time, and make cuckoo hashing work.</div><div><br/></div><div>A very interesting goal is to obtain retrieval dictionaries with close to <i>kn</i> bits. As far as I know, the state of the art is given by <a href="http://www.itu.dk/people/pagh/papers/bloomier.pdf"><span class="Apple-style-span" style="font-size: small;">[Pagh-Dietzfelbinger ICALP'08]</span></a> and <a href="http://arxiv.org/abs/0804.1845"><span class="Apple-style-span" style="font-size: small;">[Porat]</span></a>.</div></div><div class="commentbar"><p/><span class="commentbutton" href="http://infoweekly.blogspot.com/feeds/2947554534039774592/comments/default"/><a href="http://infoweekly.blogspot.com/feeds/2947554534039774592/comments/default"><img class="commenticon" src="/images/feed-icon.png"/> Subscribe to comments</a><![CDATA[  | ]]><a href="http://www.blogger.com/comment.g?blogID=786333285568106173&amp;postID=2947554534039774592"><img class="commenticon" src="/images/post-icon.png"/> Post a comment</a></div></content><updated planet:format="September 27, 2010 06:17 PM">2010-09-27T18:17:00Z</updated><published planet:format="September 27, 2010 06:17 PM">2010-09-27T18:17:00Z</published><author><name>Mihai</name><email>noreply@blogger.com</email><uri>http://www.blogger.com/profile/11599372864611039927</uri></author><source><id>tag:blogger.com,1999:blog-786333285568106173</id><author><name>Mihai</name><email>noreply@blogger.com</email><uri>http://www.blogger.com/profile/11599372864611039927</uri></author><link href="http://infoweekly.blogspot.com/" rel="alternate" type="text/html"/><link href="http://www.blogger.com/feeds/786333285568106173/posts/default?start-index=26&amp;max-results=25&amp;redirect=false" rel="next" type="application/atom+xml"/><link href="http://feeds.feedburner.com/WebdiariosDeMotocicleta" rel="self" type="application/atom+xml"/><link href="http://pubsubhubbub.appspot.com/" rel="hub" type="text/html"/><subtitle>Informatics Weekly, written by Mihai Pătraşcu.</subtitle><title>WebDiarios de Motocicleta</title><updated planet:format="September 17, 2018 03:40 AM">2018-09-17T03:40:52Z</updated><planet:module>toc</planet:module><planet:format>atom10</planet:format><planet:http_etag>p4aBUs7EfDbSpgYtTTaw3ObCwMk</planet:http_etag><planet:http_last_modified>Sun, 16 Dec 2018 15:48:09 GMT</planet:http_last_modified><planet:bozo>false</planet:bozo><planet:items_per_page>40</planet:items_per_page><planet:css-id>webdiarios-de-motocicleta</planet:css-id><planet:face>mihai.jpg</planet:face><planet:name>WebDiarios de Motocicleta</planet:name><planet:http_status>200</planet:http_status></source></entry>
