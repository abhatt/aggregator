<?xml version="1.0" encoding="utf-8"?><entry xmlns="http://www.w3.org/2005/Atom" xmlns:planet="http://planet.intertwingly.net/"><id>https://11011110.github.io/blog/2018/11/12/gurobi-vs-no</id><link href="https://11011110.github.io/blog/2018/11/12/gurobi-vs-no.html" rel="alternate" type="text/html"/><title>Gurobi versus the no-three-in-line problem</title><summary>For the no-three-in-line problem, it has been known since the 1990s that grids with have sets of points with no three in line. Those results, by Achim Flammenkamp, were based on custom search software and a lot of compute time. I was curious to see how far one could get with more-modern but generic optimization codes, so this weekend I ran a little experiment.<div class="commentbar"><p/></div></summary><content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>For the <a href="https://en.wikipedia.org/wiki/No-three-in-line_problem">no-three-in-line problem</a>, it has been known since the 1990s that  grids with  have sets of  points with no three in line. Those results, by Achim Flammenkamp, were based on custom search software and a lot of compute time. I was curious to see how far one could get with more-modern but generic optimization codes, so this weekend I ran a little experiment.</p>

<p>I think that in this area, most general-purpose solvers can be reasonably divided into two categories: integer linear program solvers, and satisfiability solvers. For the no-three-in-line problem, we have - integer variables ( if a point is included,  if it is excluded), linear constraints (the sum of variables on any line should be at most ), and a linear optimization criterion (maximize the sum of variables). So this led me to look at integer linear program solvers rather than satisfiability solvers. Based on <a href="http://strimas.com/prioritization/ilp-performance/">a comparison by Matt Strimas-Mackey</a>, I chose <a href="http://www.gurobi.com/">Gurobi</a> over several open-source alternatives. Gurobi is not open source, but it is free for academic purposes.</p>

<p>This was my first experience with an ILP solver, and my impression was that everything “just worked”. Gurobi was easy to download and install, easy to run, and easy to program following the model of their <a href="http://www.gurobi.com/documentation/8.1/quickstart_windows/py_simple_python_example.html">simple Python example</a> in their Quick Start Guide.</p>

<p>On the other hand, although it worked quickly for small grids, it was far from being able to reach the grid sizes already solved by Flammenkamp. With the formulation of the problem that I used, the boundary between easy and difficult problems was between  (five seconds to solve on my laptop) and  (thirty minutes to solve). It’s important to remember, though, that this was my first attempt at coding up anything as an integer linear program, and my first time using this system. So it’s entirely likely that an expert user of the system would know some tricks that would let it get farther.</p>

<p>Perhaps it’s also important to remember that for  it’s searching through a space of  possible solutions, and for  that blows up to approximately . So the fact that it can solve these at all, and do so relatively quickly, is quite impressive.</p>

<p>In case anyone else wants to try it, here’s my code:</p>

<figure class="highlight"><pre><code class="language-python"><span class="n">n</span> <span class="o">=</span> <span class="mi">14</span>

<span class="kn">from</span> <span class="nn">gurobipy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">fractions</span> <span class="kn">import</span> <span class="n">gcd</span>

<span class="c"># Construct the grid points and the lines through them</span>
<span class="n">points</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
<span class="n">lines</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">q</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">),</span><span class="n">c</span><span class="p">)</span>
            <span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">//</span><span class="n">g</span><span class="p">,</span><span class="n">b</span><span class="o">//</span><span class="n">g</span><span class="p">,</span><span class="n">c</span><span class="o">//</span><span class="n">g</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">L</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                <span class="n">lines</span><span class="p">[</span><span class="n">L</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lines</span><span class="p">[</span><span class="n">L</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="n">lines</span><span class="p">[</span><span class="n">L</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

<span class="c"># Create an ILP with a 0-1 variable per grid point,</span>
<span class="c"># maximizing the number of variables we set to 1</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">Model</span><span class="p">()</span>
<span class="nb">vars</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span><span class="p">:</span> <span class="n">m</span><span class="o">.</span><span class="n">addVar</span><span class="p">(</span><span class="n">vtype</span><span class="o">=</span><span class="n">GRB</span><span class="o">.</span><span class="n">BINARY</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points</span><span class="p">}</span>
<span class="n">m</span><span class="o">.</span><span class="n">setObjective</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nb">vars</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points</span><span class="p">),</span> <span class="n">GRB</span><span class="o">.</span><span class="n">MAXIMIZE</span><span class="p">)</span>

<span class="c"># Add constraints for at most two points on each line</span>
<span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="n">L</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">m</span><span class="o">.</span><span class="n">addConstr</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nb">vars</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">[</span><span class="n">L</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span>

<span class="c"># To speed things up tell it that we only care about perfect solutions</span>
<span class="n">m</span><span class="o">.</span><span class="n">addConstr</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nb">vars</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>

<span class="n">m</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;.&quot;</span>
        <span class="k">if</span> <span class="nb">vars</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;O&quot;</span>
        <span class="k">print</span> <span class="n">s</span><span class="p">,</span>
    <span class="k">print</span></code></pre></figure>

<p>It’s in Python 2 rather than Python 3 because somehow that’s the default for my installation (probably because it’s the default command-line python on my laptop).
The code after the optimize step produces a picture of the solution in crude ASCII graphics. Here’s a prettier version of the  solution:</p>

<p style="text-align: center;"><img alt="28 points in a 14x14 grid with no three in line" src="https://11011110.github.io/blog/assets/2018/no3il14x14.svg"/></p>

<p>(<a href="https://plus.google.com/100003628603413742554/posts/aEhW29MVv2H">G+</a>, <a href="https://mathstodon.xyz/@11011110/101061128588762922"/>)</p></div></content><updated planet:format="November 12, 2018 04:30 PM">2018-11-12T16:30:00Z</updated><published planet:format="November 12, 2018 04:30 PM">2018-11-12T16:30:00Z</published><author><name>David Eppstein</name></author><source><id>https://11011110.github.io/blog/feed.xml</id><author><name>David Eppstein</name></author><link href="https://11011110.github.io/blog/feed.xml" rel="self" type="application/atom+xml"/><link href="https://11011110.github.io/blog/" rel="alternate" type="text/html"/><subtitle>Geometry, graphs, algorithms, and more</subtitle><title>11011110</title><updated planet:format="December 16, 2018 12:22 AM">2018-12-16T00:22:46Z</updated><planet:module>toc</planet:module><planet:format>atom10</planet:format><planet:http_etag>W/&quot;5c159ae6-21992&quot;</planet:http_etag><planet:http_last_modified>Sun, 16 Dec 2018 00:23:02 GMT</planet:http_last_modified><planet:bozo>false</planet:bozo><planet:items_per_page>40</planet:items_per_page><planet:css-id>david-eppstein</planet:css-id><planet:face>eppstein.jpeg</planet:face><planet:name>David Eppstein</planet:name><planet:filters>category.py?cats=$%20not%20&quot;family&quot;%20and%20not%20&quot;photography&quot;</planet:filters><planet:http_status>200</planet:http_status></source></entry>

