<?xml version="1.0" encoding="utf-8"?><entry xml:lang="en" xmlns="http://www.w3.org/2005/Atom" xmlns:planet="http://planet.intertwingly.net/"><id>http://daveagp.wordpress.com/?p=1013</id><link href="https://daveagp.wordpress.com/2011/11/02/the-joy-of-randomness/" rel="alternate" type="text/html"/><title>The Joy of Randomness</title><summary>Ravi Kannan gave a distinguished lecture today at Georgia Tech covering a wide swath of algorithms, randomness, and high-dimensional geometry. There was one particularly excellent slide that gave a very intuitive explanation for a result I have seen, but not fully understood, before. The result is in the field of streaming algorithms. Specifically, there is […]<div class="commentbar"><p/></div></summary><content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>Ravi Kannan gave a distinguished lecture today at Georgia Tech covering a wide swath of algorithms, randomness, and high-dimensional geometry. There was one particularly excellent slide that gave a very intuitive explanation for a result I have seen, but not fully understood, before.</p>
<p>The result is in the field of streaming algorithms. Specifically, there is a “streaming” data set which consists of a large number <em>m</em> of elements, where each element is some <em>b-</em>bit string — actually it is more convenient to think of each element as integer between 1 and <em>n</em> := 2<em><sup>b</sup></em>. You only get to see one element from the stream at a time, do a computation and change your working memory, and then the next one arrives. We want to capture some statistical properties of this data set. Storing the entire data set could be done easily in either <em>m </em>log <em>n</em> bits, or <em>n</em> log <em>m</em> bits. But what if this is much more memory than our computer has available? (E.g. if these are a continuous stream of data points from a sensor, or requests on a web server, or Google’s cache of the internet.) We would like to say something useful about the data set using only polylog(<em>m</em>, <em>n</em>) memory.</p>
<p>First, an easier <strong>puzzle</strong>. Let’s say that we don’t precisely know in advance the total number of items (including repeats) <em>m</em> that will arrive, and want to find <em>m</em> out. (For the puzzle, we don’t care about the items’ contents.) Evidently we can just count this in a streaming manner using log <em>m </em>bits of memory.  Can we do it with less? More precisely, can we come up with a good estimate of <em>m</em> using only O(log log <em>m</em>) bits of memory? I give the answer at the end.</p>
<div class="wp-caption aligncenter" id="attachment_1018" style="width: 550px;"><a href="https://daveagp.files.wordpress.com/2011/11/101_0890.jpg"><img alt="" class="size-full wp-image-1018 " src="https://daveagp.files.wordpress.com/2011/11/101_0890.jpg?w=500" title="101_0890"/></a><p class="wp-caption-text">Part of a Stream</p></div>
<p>Back to Ravi’s talk. The particular statistic we’d like to count is the second moment. For each string <em>i</em>, let <em>f<sub>i</sub></em> be the frequency of that string, or in other words the total number of times it appears in the data set. Then the second moment is defined as <img alt="\sum_{i} f^2_i" class="latex" src="https://s0.wp.com/latex.php?latex=%5Csum_%7Bi%7D+f%5E2_i&amp;bg=ffffff&amp;fg=333333&amp;s=0" title="\sum_{i} f^2_i"/>. Put differently, the second moment is the probability that two random elements from the stream are the same, up to a factor of <em>n<sup>2</sup></em>. How can we estimate this value?</p>
<p>Ravi’s explanation of how you could imagine doing this was very nice. Think of <em>f</em> as a vector in high-dimensional space. What we want to measure is (the square of) the Euclidean length of <em>f, </em>but we don’t have the space to explicitly store all of the bits of <em>f</em> in memory. The streaming model amounts to discovering the vector <em>f</em> in unit steps. The key insight in his explanation is to use the projection of <em>f</em> on to a random <em>d</em>-dimensional subspace where <em>d</em> is logarithmic; analogous to the <a href="http://en.wikipedia.org/wiki/Johnson%E2%80%93Lindenstrauss_lemma">Johnson-Lindenstrauss lemma</a>, the random length of the projection actually gives us a pretty good estimate of the original length. Moreover, the projection of the sum of the steps is the sum of the projections of the steps. So it suffices to keep a running (vector) total of the sum of the projections of the steps.</p>
<p>A possible problem in implementing this is that projecting on to a <em>d</em>-dimensional subspace amounts to multiplying each incoming item (<em>n-</em>dimensional unit basis “step” vector) by a <em>n</em>-by-<em>d</em> matrix, and we cannot store anything of length <em>n</em>. To get around this, we let our <em>n</em>-by-<em>d</em> matrix actually be pseudorandom — that is to say, there should be some small random “seed” so that a computer program can determine the <em>n</em>-by-<em>d</em> matrix from just the seed. In this way, we don’t need to store the whole matrix in memory, rather just the seed, so that we can just recompute the <em>i</em>th row each time an element <em>i</em> shows up. In this way we can keep a running count of the <em>d</em>-dimensional vector sum and complete the idea.</p>
<p>This result is due to <a href="http://www.tau.ac.il/~nogaa/PDFS/amsz4.pdf">Alon, Matias, and Szegedy</a>, which I have heard called one of the first papers in streaming computation (1996). The paper is nice to read and gives a clean explanation where you project on to random ±1 vectors in a derandomizable way. But this intuition helps me follow the proof idea for second moments (section 2.2). I read it previously (without this intuition), back when I was working on my Master’s thesis, because I had looked at an earlier paper of Morris for estimating the first moment… and this brings me to the puzzle’s solution.</p>
<p style="text-align: center;">***</p>
<p>You may have already deduced that you would need randomness to solve the puzzle, because with only <em>O</em>(log log <em>m</em>) bits of memory, our counter could only have polylog(<em>m</em>) states, and so only count polylog(<em>m</em>) items reliably.</p>
<p>So, let’s say that we have a “log counter” instead. The log counter stores a value <em>k</em>, such that our running estimate of the number of items seen so far is 2<em><sup>k</sup></em>. Then, we maintain this counter using the probabilistic method: if the counter currently reads <em>k</em>, when the next item shows up, only increment the counter with probability 2<em><sup>-k</sup></em>. So, the counter reads 1 after the first item arrives; the expected time until it reads 2 is three items; in general the expected time until it reads <em>j</em> is 2<em><sup>j</sup></em>-1 items. You would need some more formal calculations to see exactly how good of an estimate it is, but this is the main idea.</p>
<p>The paper of Alon et al has a lot of other nice stuff. We saw small-space approximations for the first and second moments; they also formalize a previous idea for the 0th moment (counting distinct items) and show that some higher moments do not admit any small-space approximation. For recent work on this, not a bad place to start is to look at the work of <a href="http://www.dblp.org/search/index.php?query=author:daniel_m_kane%20author:jelani_nelson:">Kane &amp; Nelson et al.</a>!</p></div></content><updated planet:format="November 02, 2011 02:53 AM">2011-11-02T02:53:00Z</updated><published planet:format="November 02, 2011 02:53 AM">2011-11-02T02:53:00Z</published><category term="algorithms"/><category term="b.k.a.t."/><category term="photos"/><category term="randomness"/><category term="toc"/><author><name>daveagp</name></author><source><id>https://daveagp.wordpress.com</id><logo>https://secure.gravatar.com/blavatar/0c75bc2d5e38ccd4ac9254b60147fa59?s=96&amp;d=https%3A%2F%2Fs0.wp.com%2Fi%2Fbuttonw-com.png</logo><link href="https://daveagp.wordpress.com/category/toc/feed/" rel="self" type="application/atom+xml"/><link href="https://daveagp.wordpress.com" rel="alternate" type="text/html"/><link href="https://daveagp.wordpress.com/osd.xml" rel="search" type="application/opensearchdescription+xml"/><link href="https://daveagp.wordpress.com/?pushpress=hub" rel="hub" type="text/html"/><subtitle>Dave Pritchard's algorithms, recipes, etc</subtitle><title>toc – QED and NOM</title><updated planet:format="December 17, 2018 05:29 AM">2018-12-17T05:29:51Z</updated><planet:module>toc</planet:module><planet:format>atom10</planet:format><planet:http_etag>W/&quot;4252feb7c4c6b2e1113a66a7070692e6&quot;</planet:http_etag><planet:http_last_modified>Mon, 17 Dec 2018 05:29:50 GMT</planet:http_last_modified><planet:bozo>false</planet:bozo><planet:items_per_page>40</planet:items_per_page><planet:css-id>david-pritchard</planet:css-id><planet:face>pritchard.jpeg</planet:face><planet:name>David Pritchard</planet:name><planet:http_location>https://daveagp.wordpress.com/category/toc/feed/</planet:http_location><planet:http_status>301</planet:http_status></source></entry>
