<?xml version="1.0" encoding="utf-8"?><entry xmlns="http://www.w3.org/2005/Atom" xmlns:planet="http://planet.intertwingly.net/"><id>tag:blogger.com,1999:blog-8890204.post-4345106780105397185</id><link href="http://mybiasedcoin.blogspot.com/feeds/4345106780105397185/comments/default" rel="replies" type="application/atom+xml"/><link href="http://www.blogger.com/comment.g?blogID=8890204&amp;postID=4345106780105397185" rel="replies" type="text/html"/><link href="http://www.blogger.com/feeds/8890204/posts/default/4345106780105397185" rel="edit" type="application/atom+xml"/><link href="http://www.blogger.com/feeds/8890204/posts/default/4345106780105397185" rel="self" type="application/atom+xml"/><link href="http://mybiasedcoin.blogspot.com/2018/01/some-notes-on-learned-bloom-filters.html" rel="alternate" type="text/html"/><title>Some Notes on &quot;Learned Bloom Filters&quot;</title><content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">About a month ago, a draft paper was put out on arxiv called <a href="https://arxiv.org/abs/1712.01208">The Case for Learned Indexed Structures</a> by the people at Google Brain.  The paper has received some significant attention, perhaps because of its pedigree and perhaps because it makes some rather bold claims.  For example, a line from the abstract states &quot;In this exploratory research paper, we start from this premise and posit that all existing index structures can be replaced with other types of models, including deep-learning models, which we term learned indexes.&quot;<br/><div><br/></div><div>There has already been some pushback on some of the claims from the draft paper (see <a href="http://databasearchitects.blogspot.com/2017/12/the-case-for-b-tree-index-structures.html">here</a> for a response to the paper's discussion of B-trees, and <a href="http://dawn.cs.stanford.edu/2018/01/11/index-baselines/">here</a> for a discussion regarding that cuckoo hash tables seem to do just as well as &quot;learned&quot; hash tables).  I also read the paper and had some back and forth with the authors about some thoughts and concerns I had;  they have been both responsive and thoughtful, and I think the conversation was fruitful on both sides.  (At least, they helped me understand their work, and I hope my suggestions for them were useful.)  In what follows, I'll explain some of specific thoughts and concerns regarding their proposed learned Bloom filters.  I'll try to keep the blog post self-contained, but you may want to read their paper.  Also, I've tried to write my ideas down more formally in a short write-up.  Here's a <a href="http://www.eecs.harvard.edu/~michaelm/revised.pdf">link to a draft</a>;  this link may age out or disappear if/when I put this on arxiv.  </div><div><br/></div><div>What follows is my description (so any issues are mine, not the authors of the Learned Index paper).</div><div><br/></div><div>Recall that a Bloom filter approximately represents a set S in small space.  One can ask queries of the form:  is y an element of S.  If y is an element of S, the answer will always be yes (no false negatives), if not there is some chance of false positive.  That is, it trades off some amount of error to save space.  A key feature is that the probability that any given input y yields a false positive does not depend on y.  (Well, it does after the Bloom filter has been instantiated -- some elements give false positives, some don't.  But a priori, before you build the Bloom filter using hash functions, if you don't know the hash functions, you don't know what the false positives will be.)</div><div><br/></div><div>For the learned Bloom filter, suppose we have a very good (black-box) predictor P, which takes an input x and returns P(x), which should be interpreted as an estimate of the probability that x is an element of S.  That is, we have a function that can give a very good &quot;guess&quot; if an input x is an element of S.  Then we can use P as a &quot;pre-filter&quot; to improve our Bloom filter as follows.  When asked if x is an element of S, compute P(x), and simply return that x is in S if P(x) is larger than some suitable threshold z.  This may introduce false positives, but it may also introduce false negatives;  there may be elements x of S for which P(x) &lt; z.  To deal with those, we use a backup filter, which is just a standard Bloom filter that holds the false negatives from the pre-filter using the predictor P.  So now we accept that x is an element of S if P(x) is above the threshold, or x obtains a positive answer from the backup filter.  The backup filter also introduces false positives.  </div><div><br/></div><div>The authors of the learned index paper suggest that machine learning allows for good predictors P that require small space, thereby improving the Bloom filter in terms of space while achieving the same false positive probability.  Note that the predictor does not necessarily have to be that great;  even if half the elements of S are false negatives, the backup filter would then be a little bigger than half the size of a standard Bloom filter, so if the predictor P is suitably small, it is plausible that one could get the same performance with smaller space.</div><div><br/></div><div>I don't know if this idea is new.  I don't think I've seen a probabilistic pre-filter for a Bloom filter before;  <a href="http://mybiasedcoin.blogspot.com/2009/02/hash-table-with-preemptive-bloom-filter.html">usually a Bloom filter is a pre-filter to some other part of the system</a>.  It seems like an interesting idea;  certainly, the potential to layer filters is useful, and putting a filter before a Bloom filter is sensible.  </div><div><br/></div><div>A major issue, though, is that the nature of the guarantees one obtains are quite different for learned Bloom filters and standard Bloom filters, which is a subtlety that I worry may not be clear to all readers of the original paper.  In particular, it seems in part that confusion might arise because the term &quot;false positive rate&quot; appears to have slightly different meanings in the Bloom filter community and the machine learning community;  in the Bloom filter setting, false positive rate generally refers to that false positive probability, which is independent of the query.  In the machine learning setting, the false positive rate is an empirical quantity, which depends on the input data and the queries.  </div><div><br/></div><div>An example may be helpful;  here's one I used from the writeup.  (This is a &quot;thought-experiment&quot; example, not based on actual experiments.)  Suppose we are working with numbers in the range [0,1000000), and our learned Bloom filter is supposed to hold a set S that contains a 1000 elements.  Half of those elements are random numbers in the range [1000,2000], and half those elements are random over the rest of the range.  A good machine learning function might learn a predictor P that says that if x is in the range [1000,2000], then P(x) is &quot;large&quot; -- say around 1/2 -- and otherwise P(x) is small.  It could use a threshold z of around 0.4, in which case about half the elements of S are false negatives, and must be stored in the backup filter.  This seems like a reasonable outcome for learning.</div><div><br/></div><div>What is the false positive rate now?  Well, it depends on the queries.  If all the queries are uniform over the range [1000,2000], the false positive rate would be quite high -- every query to a non-set element would be a false positive.  If the queries are uniform over the range [0,1000000), the false positive rate is quite low, since one will rarely get unlucky and ask a query in the range [1000,2000], and otherwise the only false positives will come from the backup Bloom filter.  The point is that the false positive probability depends on the distribution of the queries (as well as the predictor).  But there may be many applications where the queries are naturally more often for elements that are &quot;similar to&quot; set elements -- that is, they have high P values, like the values in [1000,2000] that are not elements of S -- which may lead to high false positive rates.  And if you don't know the query stream in advance, you don't even know what the false positive rate will be.  </div><div><br/></div><div>The response to this seems to be that if you have data about the queries, you can figure out the false positive rate empirically.  That is, if you have a test set of queries that you assume is a sample from a distribution over all possible queries, you can determine the false positive rate of that test set, and use it to predict the false positive rate of future queries.  My writeup provides basic definitions to formalize this idea, which seems correct.  However, this still assumes that &quot;future queries&quot; will come from the same distribution as the test set.  Returning to our example, if in our test set queries are uniform over [0,1000000), but then in the future queries change so that they are uniform over a smaller interval [0,100000), that significantly changes the false positive rate of the filter.  </div><div><br/></div><div>My takeaways were the following:</div><div><ul><li>The idea of adding learning into data structures is certainly an interesting idea.</li><li>But it's still important to try to set up a theoretical framework, to understand what kinds of guarantees can be obtained.</li><li>At the moment, I can see applications where learned Bloom filters might be helpful -- if your data set has significant structure that can be useful to a machine learning function, if you don't have to deal with insertions and deletions frequently, if you have access to query data, and if you have reason to believe the query stream isn't changing (in a distributional sense).  </li><li>At the same time, I can see applications where I would be very concerned about the use of learned Bloom filters, such as in a security setting.  Also, modern Bloom filter alternatives, such as <a href="http://mybiasedcoin.blogspot.com/2014/10/cuckoo-filters.html">cuckoo filters</a> (which use less space, and allow insertions/deletions more easily) should be considered and compared when thinking about using learned Bloom filters.  </li><li>There's probably more to think about here.  In particular, I wonder if there are other places where additional &quot;filter layering&quot; may be useful.  </li></ul></div><div><br/></div><div/><div>  </div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div><div class="commentbar"><p/><span class="commentbutton" href="http://mybiasedcoin.blogspot.com/feeds/4345106780105397185/comments/default"/><a href="http://mybiasedcoin.blogspot.com/feeds/4345106780105397185/comments/default"><img class="commenticon" src="/images/feed-icon.png"/> Subscribe to comments</a><![CDATA[  | ]]><a href="http://www.blogger.com/comment.g?blogID=8890204&amp;postID=4345106780105397185"><img class="commenticon" src="/images/post-icon.png"/> Post a comment</a></div></content><updated planet:format="January 25, 2018 02:12 PM">2018-01-25T14:12:00Z</updated><published planet:format="January 25, 2018 02:12 PM">2018-01-25T14:12:00Z</published><author><name>Michael Mitzenmacher</name><email>noreply@blogger.com</email><uri>http://www.blogger.com/profile/02161161032642563814</uri></author><source><id>tag:blogger.com,1999:blog-8890204</id><category term="conferences"/><category term="research"/><category term="society"/><category term="algorithms"/><category term="administration"/><category term="teaching"/><category term="Harvard"/><category term="papers"/><category term="graduate students"/><category term="funding"/><category term="talks"/><category term="blogs"/><category term="codes"/><category term="jobs"/><category term="reviews"/><category term="personal"/><category term="travel"/><category term="undergraduate students"/><category term="books"/><category term="open problems"/><category term="PCs"/><category term="consulting"/><category term="randomness"/><category term="CCC"/><category term="blog book project"/><category term="research labs"/><category term="ISIT"/><category term="tenure"/><category term="comments"/><category term="recommendations"/><category term="outreach"/><category term="students"/><author><name>Michael Mitzenmacher</name><email>noreply@blogger.com</email><uri>http://www.blogger.com/profile/06738274256402616703</uri></author><link href="http://mybiasedcoin.blogspot.com/feeds/posts/default" rel="http://schemas.google.com/g/2005#feed" type="application/atom+xml"/><link href="http://www.blogger.com/feeds/8890204/posts/default" rel="self" type="application/atom+xml"/><link href="http://mybiasedcoin.blogspot.com/" rel="alternate" type="text/html"/><link href="http://pubsubhubbub.appspot.com/" rel="hub" type="text/html"/><link href="http://www.blogger.com/feeds/8890204/posts/default?start-index=26&amp;max-results=25" rel="next" type="application/atom+xml"/><subtitle type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">My take on computer science -- <br/> 
algorithms, networking, information theory -- <br/> 
and related items.</div></subtitle><title>My Biased Coin</title><updated planet:format="December 12, 2018 11:01 AM">2018-12-12T11:01:52Z</updated><planet:module>toc</planet:module><planet:format>atom10</planet:format><planet:http_etag>W/&quot;9b7f47a041c10afec7c82a4909c6ce038e47f345b401a61a2681d18f20b0c3ba&quot;</planet:http_etag><planet:http_last_modified>Wed, 12 Dec 2018 11:01:52 GMT</planet:http_last_modified><planet:bozo>false</planet:bozo><planet:items_per_page>40</planet:items_per_page><planet:css-id>michael-mitzenmacher</planet:css-id><planet:face>mitzenmacher.jpeg</planet:face><planet:name>Michael Mitzenmacher</planet:name><planet:http_status>200</planet:http_status></source></entry>
