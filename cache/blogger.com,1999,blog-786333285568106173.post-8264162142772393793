<?xml version="1.0" encoding="utf-8"?><entry xmlns="http://www.w3.org/2005/Atom" xmlns:planet="http://planet.intertwingly.net/"><id>tag:blogger.com,1999:blog-786333285568106173.post-8264162142772393793</id><link href="http://infoweekly.blogspot.com/feeds/8264162142772393793/comments/default" rel="replies" type="application/atom+xml"/><link href="http://www.blogger.com/comment.g?blogID=786333285568106173&amp;postID=8264162142772393793" rel="replies" type="text/html"/><link href="http://www.blogger.com/feeds/786333285568106173/posts/default/8264162142772393793" rel="edit" type="application/atom+xml"/><link href="http://www.blogger.com/feeds/786333285568106173/posts/default/8264162142772393793" rel="self" type="application/atom+xml"/><link href="http://infoweekly.blogspot.com/2010/09/van-emde-boas-and-its-space-complexity.html" rel="alternate" type="text/html"/><title>Van Emde Boas and its space complexity</title><content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">In this post, I want to describe 3 neat and very different ways of making the space of the van Emde Boas (vEB) data structure linear. While this is not hard, it is subtle enough to confuse even seasoned researchers at times. In particular, it is the first bug I ever encountered in a class: Erik Demaine was teaching Advanced Data Structures at MIT in spring of 2003 (the first grad course I ever took!), and his solution for getting linear space was flawed. <div><br/></div><div>Erik is the perfect example of how you can get astronomically high teaching grades while occasionally having bugs in your lectures. In fact, I sometimes suspected him of doing it on purpose: deliberately letting a bug slip by to make the course more interactive. Perhaps there is a lesson to be learned here.</div><div><br/><div style="text-align: center;">***</div><div><br/></div><div>Here is a quick review of vEB if you don't know it. Experienced readers can skip ahead.</div><div><br/></div><div>The predecessor problem is to support a set <i>S</i> of |<i>S</i>|=<i>n</i> integers from the universe {1, ..., <i>u</i>} and answer:<br/><blockquote>predecessor(<i>q</i>) = max { <i>x</i> ∈ <i>S</i> | <i>x</i> ≤ <i>q</i> }</blockquote></div>The vEB data structure can answer queries in O(lglg <i>u</i>) time, which is significantly faster than binary search for moderate universes.</div><div><br/></div><div>The first idea is to divide the universe into √<i>u </i>segments of size √<i>u. </i>Let hi(<i>x</i>) = ⌊<i>x</i>/√<i>u</i>⌋ be the segment containing <i>x</i>, and lo(<i>x</i>) = <i>x</i> mod √<i>u </i>be the location of <i>x</i> within its segment. The data structure has the following components:</div><div><ul><li>a hash table <i>H</i> storing hi(<i>x</i>) for all <i>x</i> ∈ <i>S</i>.</li><li>a top structure solving predecessor search among { hi(<i>x</i>) | <i>x</i> ∈ <i>S</i> }. This is the same as the original data structure, i.e. use recursion.</li><li>for each element α∈<i>H</i>, a recursive bottom structure solving predecessor search inside the α segment, i.e. among the keys { lo(<i>x</i>) | <i>x</i> ∈ <i>S</i> and hi(<i>x</i>)=α }.</li></ul><div>The query algorithm first checks if hi(<i>q</i>) ∈ <i>H</i>.  If so, all the action is in <i>q</i>'s segment, so you recurse in the appropriate bottom structure. (You either find its predecessor there, or in the special case when <i>q </i>is less than the minimum in that segment, find the successor and follow a pointer in a doubly linked list.)</div><div><br/></div><div>If <i>q</i>'s segment is empty, all the action is at the segment level, and <i>q</i>'s predecessor is the max in the preceding non-empty segment. So you recurse in the top structure.</div><div><br/></div><div>In one step, the universe shrinks from <i>u</i> to √<i>u</i>, i.e. lg <i>u </i>shrinks to ½ lg <i>u.</i> Thus, in O(lglg <i>u</i>) steps the problem is solved.</div><div><br/></div><div><div>***</div><div><br/></div><div>So what is the space of this data structure? As described above, each key appears in the hash table, and in 2 recursive data structures. So the space per key obeys the recursion S(<i>u</i>) = 1 + 2 S(√<i>u</i>). Taking logs: S'(lg <i>u</i>) = 1 + 2 S'(½ lg <i>u</i>), so the space is O(lg <i>u</i>) per key.</div><div><br/></div><div>How can we reduce this to space O(<i>n</i>)? Here are 3 very different ways:</div></div></div><div><br/></div><div><b>Brutal bucketing.</b> Group elements into buckets of O(lg <i>u</i>) consecutive elements. From each bucket, we insert the min into a vEB data structure. Once we find a predecessor in the vEB structure, we know the bucket where we must search for the real predecessor. We can use binary search inside the bucket, taking time O(lglg <i>u</i>). The space is (<i>n</i>/lg <i>u</i>) ·lg <i>u</i> = O(<i>n</i>).</div><div><br/></div><div><br/></div><div><b>Better analysis. </b>In fact, the data structure from above does take O(<i>n</i>) space if you analyze it better! For each segment, we need to remember the max inside the segment in the hash table, since a query in the top structure must translate the segment number into the real predecessor. But then there's no point in putting the max in the bottom structure: once the query accesses the hash table, it can simply compare with the max in O(1) time. (If the query is higher than the max in its segment, the max is the predecessor.)</div><div><br/></div><div>In other words, every key is stored recursively in just one data structure: either the top structure (for each segment max) or the bottom structure (for all other keys). This means there are O(lglg <i>u</i>) copies of each element, so space O(<i>n</i> lglg <i>u</i>).</div><div><br/></div><div>But note that copies get geometrically cheaper! At the first level, keys are lg <i>u</i> bits. At the second level, they are only ½ lg <i>u </i>bits; etc. Thus, the cost per key, in bits, is a geometric series, which is bounded by O(lg <i>u</i>). In other words, the cost is only O(1) words per key. (You may ask: even if the cost of keys halves every time, what about the cost of pointers, counters, etc? The cost of a pointer is O(lg <i>n</i>) bits, and <i>n</i> ≤ <i>u</i> in any recursive data structure.)</div><div><br/></div><div><b><br/></b></div><div><b>Be slick. </b>Here's a trickier variation due to <a href="http://www.itu.dk/~pagh/">Rasmus Pagh</a>. Consider the trie representing the set of keys (a trie is a perfect binary tree of depth lg <i>u </i>in which each key is a root-to-leaf path). The subtree induced by the keys has <i>n</i>-1 branching nodes, connected by 2<i>n</i>-1 unbranching paths. It suffices to find the lowest branching node above the query. (If each branching node stores a pointer to his children, and the min and max values in its subtree, we can find the predecessor with constant work after knowing the lowest branching node.)</div><div><br/></div><div>We can afford space O(1) per path. The data structure stores:</div><div><ul><li>a top structure, with all paths that begin and end above height ½ lg <i>u.</i></li><li>a hash table <i>H </i>with the nodes at depth ½ lg <i>u </i>of every path <i>crossing </i>this depth.</li><li>for each α∈<i>H</i>, a bottom structure with all paths starting below depth ½ lg <i>u </i>which have α as prefix.</li></ul><div>Observe that each path is stored in exactly one place, so the space is linear. But why can we query for the lowest branching node above some key? As the query proceeds, we keep a pointer <i>p</i> to the lowest branching node found so far. Initially <i>p </i>is the root. Here is the query algorithm:</div></div><div><ul><li>if <i>p </i>is below depth ½ lg <i>u</i>, recurse in the appropriate bottom structure. (We have no work to do on this level.)</li><li>look in <i>H</i> for the node above the query at depth ½ lg <i>u. </i>If not found, recurse in the top structure. If found, let <i>p </i>be the bottom node of the path crossing depth ½ lg <i>u </i>which we just found in the hash table. Recurse to the appropriate bottom structure.</li></ul><div>The main point is that a path is only relevant once, at the highest level of the recursion where the path crosses the middle line. At lower levels the path cannot be queried, since if you're on the path you already have a pointer to the node at the bottom of the path!</div></div></div><div class="commentbar"><p/><span class="commentbutton" href="http://infoweekly.blogspot.com/feeds/8264162142772393793/comments/default"/><a href="http://infoweekly.blogspot.com/feeds/8264162142772393793/comments/default"><img class="commenticon" src="/images/feed-icon.png"/> Subscribe to comments</a><![CDATA[  | ]]><a href="http://www.blogger.com/comment.g?blogID=786333285568106173&amp;postID=8264162142772393793"><img class="commenticon" src="/images/post-icon.png"/> Post a comment</a></div></content><updated planet:format="September 19, 2010 06:34 PM">2010-09-19T18:34:00Z</updated><published planet:format="September 19, 2010 06:34 PM">2010-09-19T18:34:00Z</published><author><name>Mihai</name><email>noreply@blogger.com</email><uri>http://www.blogger.com/profile/11599372864611039927</uri></author><source><id>tag:blogger.com,1999:blog-786333285568106173</id><author><name>Mihai</name><email>noreply@blogger.com</email><uri>http://www.blogger.com/profile/11599372864611039927</uri></author><link href="http://infoweekly.blogspot.com/" rel="alternate" type="text/html"/><link href="http://www.blogger.com/feeds/786333285568106173/posts/default?start-index=26&amp;max-results=25&amp;redirect=false" rel="next" type="application/atom+xml"/><link href="http://feeds.feedburner.com/WebdiariosDeMotocicleta" rel="self" type="application/atom+xml"/><link href="http://pubsubhubbub.appspot.com/" rel="hub" type="text/html"/><subtitle>Informatics Weekly, written by Mihai Pătraşcu.</subtitle><title>WebDiarios de Motocicleta</title><updated planet:format="September 17, 2018 03:40 AM">2018-09-17T03:40:52Z</updated><planet:module>toc</planet:module><planet:format>atom10</planet:format><planet:http_etag>p4aBUs7EfDbSpgYtTTaw3ObCwMk</planet:http_etag><planet:http_last_modified>Sun, 16 Dec 2018 15:48:09 GMT</planet:http_last_modified><planet:bozo>false</planet:bozo><planet:items_per_page>40</planet:items_per_page><planet:css-id>webdiarios-de-motocicleta</planet:css-id><planet:face>mihai.jpg</planet:face><planet:name>WebDiarios de Motocicleta</planet:name><planet:http_status>200</planet:http_status></source></entry>
