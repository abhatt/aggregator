<?xml version="1.0" encoding="utf-8"?><entry xmlns="http://www.w3.org/2005/Atom" xmlns:planet="http://planet.intertwingly.net/"><id>tag:blogger.com,1999:blog-21224994.post-749275968056489402</id><link href="https://research.googleblog.com/feeds/749275968056489402/comments/default" rel="replies" type="application/atom+xml"/><link href="https://research.googleblog.com/2017/04/consistent-hashing-with-bounded-loads.html#comment-form" rel="replies" type="text/html"/><link href="https://www.blogger.com/feeds/21224994/posts/default/749275968056489402" rel="edit" type="application/atom+xml"/><link href="https://www.blogger.com/feeds/21224994/posts/default/749275968056489402" rel="self" type="application/atom+xml"/><link href="https://research.googleblog.com/2017/04/consistent-hashing-with-bounded-loads.html" rel="alternate" type="text/html"/><title>Consistent Hashing with Bounded Loads</title><content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><span class="byline-author">Posted by Vahab Mirrokni, Principal Scientist, Morteza Zadimoghaddam, Research Scientist, NYC Algorithms Team</span><br/><br/>Running a large-scale web service, such as content hosting, necessarily requires <a href="https://en.wikipedia.org/wiki/Load_balancing_(computing)">load balancing</a> — distributing clients <i>uniformly</i> across multiple servers such that none get overloaded. Further, it is desirable to find an allocation that does not change very much over time in a <i>dynamic</i> environment in which both clients and servers can be added or removed at any time. In other words, we need the allocation of clients to servers to be <i>consistent</i> over time.<br/><br/>In collaboration with <a href="http://www.diku.dk/~mthorup/">Mikkel Thorup</a>, a visiting researcher from university of Copenhagen, we developed a new efficient allocation algorithm for this problem with <i>tight guarantees</i> on the maximum load of each server, and studied it theoretically and empirically. We then worked with our Cloud team to implement it in <a href="https://cloud.google.com/pubsub/">Google Cloud Pub/Sub</a>, a scalable event streaming service, and observed substantial improvement on uniformity of the load allocation (in terms of the maximum load assigned to servers) while maintaining consistency and stability objectives. In August 2016 we described our algorithm in the paper “<a href="https://arxiv.org/abs/1608.01350">Consistent Hashing with Bounded Loads</a>”, and shared it on ArXiv for potential use by the broader research community. <br/><br/>Three months later, Andrew Rodland from <a href="https://vimeo.com/">Vimeo</a> informed us that he had found the paper, implemented it in <a href="https://github.com/arodland/haproxy/commit/b02bed24daf64743cb9a571e93ed29ee4bc7efe7">haproxy</a> (a widely-used piece of open source software), and used it for their load balancing project at Vimeo. The results were dramatic: applying these algorithmic ideas helped them decrease the cache bandwidth by a factor of almost 8, eliminating a scaling bottleneck. He recently summarized this story in a <a href="https://medium.com/vimeo-engineering-blog/improving-load-balancing-with-a-new-consistent-hashing-algorithm-9f1bd75709ed">blog post</a> detailing his use case. Needless to say, we were excited to learn that our theoretical research was not only put into application, but also that it was useful <i>and</i> open-sourced. <br/><br/><b>Background</b><br/>While the concept of <a href="https://en.wikipedia.org/wiki/Consistent_hashing">consistent hashing</a> has been developed in the past to deal with load balancing in dynamic environments, a fundamental issue with all the previously developed schemes is that, in certain scenarios, they may result in sub-optimal load balancing on many servers. <br/><br/>Additionally, both clients and servers may be added or removed periodically, and with such changes, we do not want to move too many clients. Thus, while the dynamic allocation algorithm has to always ensure a proper load balancing, it should also aim to minimize the number of clients moved after each change to the system. Such allocation problems become even more challenging when we face hard constraints on the capacity of each server - that is, each server has a capacity that the load may not exceed. Typically, we want capacities close to the average loads. <br/><br/>In other words, we want to simultaneously achieve both <i>uniformity</i> and <i>consistency</i> in the resulting allocations. There is a vast amount of literature on solutions in the much simpler case where the set of servers is fixed and only the client set is updated, but in this post we discuss solutions that are relevant in the fully <i>dynamic</i> case where both clients and servers can be added and removed. <br/><br/><b>The Algorithm</b><br/>We can think about the servers as bins and clients as balls to have a similar notation with well-studied <a href="https://en.wikipedia.org/wiki/Balls_into_bins">balls-to-bins stochastic processes</a>. The uniformity objective encourages all bins to have a load roughly equal to the average density (the number of balls divided by the number of bins). For some parameter ε, we set the capacity of each bin to either <a href="https://en.wikipedia.org/wiki/Floor_and_ceiling_functions">floor or ceiling</a> of the average load times (1+ε). This extra capacity allows us to design an allocation algorithm that meets the consistency objective in addition to the uniformity property. <br/><br/>Imagine a given range of numbers overlaid on a circle. We apply a hash function to balls and a separate hash function to bins to obtain numbers in that range that correspond to positions on that circle. We then start allocating balls in a specific order independent of their hash values (let’s say based on their ID). Then each ball is moved clockwise and is assigned to the first bin with spare capacity. <br/><div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-pgZ4b9H7VlM/WOJ91rDe_XI/AAAAAAAABqw/wIjtyPHheFgyHpXIqY4qNLhd_H9DnHsXACLcB/s1600/image00.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="588" src="https://3.bp.blogspot.com/-pgZ4b9H7VlM/WOJ91rDe_XI/AAAAAAAABqw/wIjtyPHheFgyHpXIqY4qNLhd_H9DnHsXACLcB/s640/image00.png" width="640"/></a></div>Consider the example above where 6 balls and 3 bins are assigned using two separate hash functions to random locations on the circle. For the sake of this instance, assume the capacity of each bin is set to 2. We start allocating balls in the increasing order of their ID values. Ball number 1 moves clockwise, and goes to bin C. Ball number 2 goes to A. Balls 3 and 4 go to bin B. Ball number 5 goes to bin C. Then ball number 6 moves clockwise and hits bin B first. However bin B has capacity 2 and already contains balls 3 and 4. So ball 6 keeps moving to reach bin C but that bin is also full. Finally, ball 6 ends up in bin A that has a spare slot for it.<br/><br/>Upon any update in the system (ball or bin insertion/deletion), the allocation is recomputed to keep the uniformity objective. The art of the analysis is to show that a small update (a few number of insertions and deletions) results in minor changes in the state of the allocation and therefore the consistency objective is met. In <a href="https://arxiv.org/abs/1608.01350">our paper</a> we show that every ball removal or insertion in the system results in O(1/ε<sup>2</sup>) movements of other balls. The most important thing about this upper bound is that it is independent of the total number of balls or bins in the system. So if the number of balls or bins are doubled, this bound will not change. Having an upper bound independent of the number of balls or bins introduces room for scalability as the consistency objective is not violated if we move to bigger instances. Simulations for the number of movements (relocations) per update is shown below when an update occurs on a bin/server. <br/><div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-IJFOHvSomXY/WOJ-AecmDaI/AAAAAAAABq0/wVAwJd8jxNs7cT30aU0ek3_WpPzYYSO9ACLcB/s1600/image01.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="505" src="https://3.bp.blogspot.com/-IJFOHvSomXY/WOJ-AecmDaI/AAAAAAAABq0/wVAwJd8jxNs7cT30aU0ek3_WpPzYYSO9ACLcB/s640/image01.png" width="640"/></a></div>The red curve shows the average number of movements and the blue bars indicate the variance for different values of ε (the x-axis). The dashed curve is the upper bound suggested by our theoretical results which fits nicely as a prediction of the actual number of movements. Furthermore, for any value of ε, we know the load of each bin is at most (1+ε) times the average load. Below we see the load distribution of bins for different values of ε=0.1, ε=0.3 and ε=0.9.<br/><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="https://1.bp.blogspot.com/-PUdBAM5bDKk/WOJ-Hm3HAgI/AAAAAAAABq4/iREEzcJjdIQ7YYYE6bfGIEsbQALIozEKgCLcB/s1600/image02.png" style="margin-left: auto; margin-right: auto;"><img border="0" height="532" src="https://1.bp.blogspot.com/-PUdBAM5bDKk/WOJ-Hm3HAgI/AAAAAAAABq4/iREEzcJjdIQ7YYYE6bfGIEsbQALIozEKgCLcB/s640/image02.png" width="640"/></a></td></tr><tr><td class="tr-caption" style="text-align: center;">The distribution of loads for several values of ε. The load distribution is nearly uniform covering all ranges of loads from 0 to (1+ε) times average, and many bins with load equal to (1+ε) times average.</td></tr></tbody></table>As one can see there is a tradeoff — a lower ε helps with uniformity but not with consistency, while larger ε values help with consistency. A lower ε will ensure that many loads will be equal to the hard capacity limit of (1+ε) times the average, and the rest have a decaying distribution.<br/><br/>When providing content hosting services, one must be ready to face a variety of instances with different characteristics. This consistent hashing scheme is ideal for such scenarios as it performs well even for worst-case instances. <br/><br/>While our internal results are exciting, we are even more pleased that the broader community found our solution useful enough to <a href="https://github.com/arodland/haproxy">open-source</a>, allowing anyone to use this algorithm. If you are interested in further details of this research, please see the <a href="https://arxiv.org/abs/1608.01350">paper</a> on ArXiv, and stay tuned for more research from the <a href="https://research.google.com/teams/nycalg/">NYC Algorithms Team</a>!<br/><br/><b>Acknowledgements:</b><br/>We would like to thank Alex Totok, Matt Gruskin, Sergey Kondratyev and Haakon Ringberg from the Google Cloud Pub/Sub team, and of course <a href="http://www.diku.dk/~mthorup/">Mikkel Thorup</a> for his invaluable contributions to this paper.</div><div class="commentbar"><p/><span class="commentbutton" href="https://research.googleblog.com/feeds/749275968056489402/comments/default"/><a href="https://research.googleblog.com/feeds/749275968056489402/comments/default"><img class="commenticon" src="/images/feed-icon.png"/> Subscribe to comments</a><![CDATA[  | ]]><a href="https://research.googleblog.com/2017/04/consistent-hashing-with-bounded-loads.html#comment-form"><img class="commenticon" src="/images/post-icon.png"/> Post a comment</a></div></content><updated planet:format="April 03, 2017 05:00 PM">2017-04-03T17:00:00Z</updated><published planet:format="April 03, 2017 05:00 PM">2017-04-03T17:00:00Z</published><category scheme="http://www.blogger.com/atom/ns#" term="Algorithms"/><category scheme="http://www.blogger.com/atom/ns#" term="Computer Science"/><category scheme="http://www.blogger.com/atom/ns#" term="Google Cloud Platform"/><category scheme="http://www.blogger.com/atom/ns#" term="optimization"/><author><name>Google AI Blog</name><email>noreply@blogger.com</email><uri>https://plus.google.com/101673966767287570260</uri></author><source><id>tag:blogger.com,1999:blog-21224994</id><category term="Machine Learning"/><category term="Google Brain"/><category term="Deep Learning"/><category term="Education"/><category term="University Relations"/><category term="TensorFlow"/><category term="Publications"/><category term="open source"/><category term="Computer Vision"/><category term="Research"/><category term="Natural Language Processing"/><category term="conference"/><category term="Neural Networks"/><category term="conferences"/><category term="Natural Language Understanding"/><category term="Research Awards"/><category term="MOOC"/><category term="Computer Science"/><category term="Machine Perception"/><category term="datasets"/><category term="Machine Intelligence"/><category term="YouTube"/><category term="Awards"/><category term="Algorithms"/><category term="Android"/><category term="Computational Photography"/><category term="Health"/><category term="Quantum Computing"/><category term="Speech"/><category term="Visualization"/><category term="ACM"/><category term="CVPR"/><category term="K-12"/><category term="Structured Data"/><category term="Earth Engine"/><category term="Machine Translation"/><category term="Security and Privacy"/><category term="Voice Search"/><category term="ph.d. fellowship"/><category term="Google Accelerated Science"/><category term="HCI"/><category term="Image Processing"/><category term="Search"/><category term="grants"/><category term="AI"/><category term="Collaboration"/><category term="Faculty Summit"/><category term="Graph Mining"/><category term="NIPS"/><category term="TTS"/><category term="Vision Research"/><category term="market algorithms"/><category term="statistics"/><category term="Course Builder"/><category term="Google Cloud Platform"/><category term="Google Genomics"/><category term="Google+"/><category term="Robotics"/><category term="Speech Recognition"/><category term="Translate"/><category term="UI"/><category term="User Experience"/><category term="WWW"/><category term="optimization"/><category term="ACL"/><category term="Fusion Tables"/><category term="Google Books"/><category term="Google Maps"/><category term="ICML"/><category term="Information Retrieval"/><category term="Moore's Law"/><category term="Ngram"/><category term="On-device Learning"/><category term="Physics"/><category term="data science"/><category term="renewable energy"/><category term="App Engine"/><category term="Art"/><category term="Chemistry"/><category term="Computational Imaging"/><category term="Diversity"/><category term="Europe"/><category term="Expander"/><category term="Gmail"/><category term="Google Play Apps"/><category term="Google Translate"/><category term="Hardware"/><category term="ICLR"/><category term="Image Classification"/><category term="Internet of Things"/><category term="Machine Hearing"/><category term="NLP"/><category term="Networks"/><category term="PhD Fellowship"/><category term="Pixel"/><category term="Semi-supervised Learning"/><category term="Software"/><category term="Virtual Reality"/><category term="accessibility"/><category term="crowd-sourcing"/><category term="distributed systems"/><category term="economics"/><category term="internationalization"/><category term="publication"/><category term="search ads"/><category term="wikipedia"/><category term="API"/><category term="Acoustic Modeling"/><category term="App Inventor"/><category term="Audio"/><category term="Automatic Speech Recognition"/><category term="China"/><category term="Cloud Computing"/><category term="Data Discovery"/><category term="DeepDream"/><category term="DeepMind"/><category term="EMEA"/><category term="Environment"/><category term="Exacycle"/><category term="Google Drive"/><category term="Google Science Fair"/><category term="Graph"/><category term="Inbox"/><category term="KDD"/><category term="Labs"/><category term="MapReduce"/><category term="Optical Character Recognition"/><category term="Policy"/><category term="Quantum AI"/><category term="Social Networks"/><category term="Supervised Learning"/><category term="Systems"/><category term="VLDB"/><category term="Video Analysis"/><category term="ads"/><category term="schema.org"/><category term="trends"/><category term="video"/><category term="Adaptive Data Analysis"/><category term="Africa"/><category term="Android Wear"/><category term="April Fools"/><category term="Augmented Reality"/><category term="Australia"/><category term="Cantonese"/><category term="Chrome"/><category term="Conservation"/><category term="Data Center"/><category term="EMNLP"/><category term="Electronic Commerce and Algorithms"/><category term="Encryption"/><category term="Entity Salience"/><category term="Faculty Institute"/><category term="Flu Trends"/><category term="Gboard"/><category term="Google Docs"/><category term="Google Photos"/><category term="Google Sheets"/><category term="Google Trips"/><category term="Google Voice Search"/><category term="Government"/><category term="High Dynamic Range Imaging"/><category term="ICSE"/><category term="IPython"/><category term="Image Annotation"/><category term="India"/><category term="Interspeech"/><category term="Journalism"/><category term="Keyboard Input"/><category term="Klingon"/><category term="Korean"/><category term="Linear Optimization"/><category term="Low-Light Photography"/><category term="ML"/><category term="Magenta"/><category term="Market Research"/><category term="Mixed Reality"/><category term="Multimodal Learning"/><category term="NAACL"/><category term="Network Management"/><category term="Nexus"/><category term="Peer Review"/><category term="PhotoScan"/><category term="PiLab"/><category term="Professional Development"/><category term="Proposals"/><category term="Public Data Explorer"/><category term="SIGCOMM"/><category term="SIGMOD"/><category term="Semantic Models"/><category term="Site Reliability Engineering"/><category term="Style Transfer"/><category term="TPU"/><category term="TV"/><category term="TensorBoard"/><category term="UNIX"/><category term="Visiting Faculty"/><category term="Wiki"/><category term="adsense"/><category term="adwords"/><category term="correlate"/><category term="electronics"/><category term="entities"/><category term="gamification"/><category term="jsm"/><category term="jsm2011"/><category term="localization"/><category term="operating systems"/><category term="osdi"/><category term="osdi10"/><category term="patents"/><category term="resource optimization"/><author><name>Google Blogs</name><email>noreply@blogger.com</email></author><link href="https://research.googleblog.com/feeds/posts/default" rel="http://schemas.google.com/g/2005#feed" type="application/atom+xml"/><link href="https://www.blogger.com/feeds/21224994/posts/default/-/Algorithms" rel="self" type="application/atom+xml"/><link href="https://research.googleblog.com/search/label/Algorithms" rel="alternate" type="text/html"/><link href="http://pubsubhubbub.appspot.com/" rel="hub" type="text/html"/><subtitle>The latest news from Research at Google</subtitle><title>Research Blog</title><updated planet:format="December 15, 2018 12:24 PM">2018-12-15T12:24:56Z</updated><planet:module>toc</planet:module><planet:format>atom10</planet:format><planet:http_etag>W/&quot;d655fa9ddde176e40cae140e16fa1ab52f15af05d220c59bde5ea7ac65f02d30&quot;</planet:http_etag><planet:http_last_modified>Sat, 15 Dec 2018 12:24:56 GMT</planet:http_last_modified><planet:bozo>false</planet:bozo><planet:items_per_page>40</planet:items_per_page><planet:css-id>google-research-blog-algorithms</planet:css-id><planet:face>google.png</planet:face><planet:name>Google Research Blog: Algorithms</planet:name><planet:http_status>200</planet:http_status></source></entry>
