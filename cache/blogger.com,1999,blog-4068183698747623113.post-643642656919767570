<?xml version="1.0" encoding="utf-8"?><entry xmlns="http://www.w3.org/2005/Atom" xmlns:planet="http://planet.intertwingly.net/"><id>tag:blogger.com,1999:blog-4068183698747623113.post-643642656919767570</id><link href="http://teachingintrotocs.blogspot.com/feeds/643642656919767570/comments/default" rel="replies" type="application/atom+xml"/><link href="http://teachingintrotocs.blogspot.com/2011/10/algorithms-success-story-part-22.html#comment-form" rel="replies" type="text/html"/><link href="http://www.blogger.com/feeds/4068183698747623113/posts/default/643642656919767570" rel="edit" type="application/atom+xml"/><link href="http://www.blogger.com/feeds/4068183698747623113/posts/default/643642656919767570" rel="self" type="application/atom+xml"/><link href="http://teachingintrotocs.blogspot.com/2011/10/algorithms-success-story-part-22.html" rel="alternate" type="text/html"/><title>Algorithms: a success story (Part 2/2)</title><content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">The paper is called: &quot;Finding undetected protein associations in cell signaling by belief propagation&quot;, the method is belief propagation, and the authors are Bailly-Bechet, Borgs, Braunstein, Chayes, Dagkessamanskaia, Francois and Zecchina. On benchmarks, their algorithm, compared to some CPLEX-based algorithm, finds Steiner tree solutions that are marginally better (by about 1%), but more importantly,  the runtime is also better, by almost two orders of magnitude. So, how do they &quot;solve&quot; prize-collecting Steiner tree with belief propagation? Here is the idea, as far as I understand it.<br/><br/><b>Step one:</b> model the problem locally.  Consider a Steiner tree. Root it at some vertex r and label each vertex i of the tree with its distance d(i) to r on the tree and its parent p(i) in the tree; label each vertex i not in the tree with  some convention, for example, d(i) arbitrary and p(i)=0. A configuration consists of a value (d(i),p(i)) for each vertex of the graph, such that d(r)=0  and such that neighboring vertices have consistent values (in particular d(p(i))=d(i)-1 for i in the tree and not equal to r). We now have a banal constraint programming problem.<br/><br/><b>Step two:</b> borrow intuition from statistical physics. Take a parameter b and define a distribution on Steiner trees, such that each tree T has probability proportional to exp(-b cost(T)). When b goes to infinity, the distribution is concentrated on the optimal Steiner tree. The crucial step: we now write the mysterious-looking, mysterious-sounding &quot;cavity equations&quot;. (Those have nothing to do with the Brown CAVE project.)<br/><br/>Consider two adjacent vertices j and i.  Let P(d(j),p(j), i) be defined as  the probability that j is in the state (d(j),p(j)) in a certain graph:  in the case where p(j) is different from i, it is the graph where every edge adjacent to i is removed; in the case where p(j)=i, it is the graph where every edge adjacent to i is removed, except {i,j}. Then the tree has to pay the cost of the edge from j to p(j), and, given the state of j, the states of the other neighbors k of j are essentially independent from one another, or at least, we hallucinate that that is the case, as if vertex {j} was a cut:<br/><br/>P(d(j),p(j),i)= exp(-b cost({j,p(j)}))*prod[ Q(k,d(j),p(j))],<br/><br/>where the product is over every neighbor k of j other than i, and Q is the probability that, in a certain graph, k is in a state consistent with (d(j),p(j)): <br/><br/>Q(k,d(j),p(j))=sum P(d(k),p(k),i),<br/><br/>where the sum is over (d(k),p(k)) compatible with (d(j),p(j)).<br/><br/>When the graph is a tree, if we write those equations going bottom up in the tree, we see that they are equivalent to a simple dynamic program to compute the distribution, so these equations exactly capture the distribution. When the graph has only one cycle, this approach has also been shown to be correct. When the graph is sparse with high girth and the influence of values on the objective decays quickly, one intuitively expects this to work reasonably well, but theoretically it's a big mess, both in terms of convergence and in terms of guarantees on the limit solution.<br/><br/><b>Step three:</b> To solve the cavity equations, use an iterative method from some perhaps random starting point, until a fixed point is reached. <br/>P(d(j),p(j),i)[t+1]  = exp(-b cost({j,p(j)}))*prod[ Q(k,d(j),p(j))[t]]<br/>Q(k,d(j),p(j))[t+1] = sum P(d(k),p(k),i)[t],<br/>That fixed point can then be reinterpreted as a particular Steiner tree. <br/><br/><b>Step four:</b> to make the method effective, use various tricks, clever ideas and hacks to speed it up and make it more convergent:  take logs, simplify the set of variables, get rid of the &quot;guess&quot; of r, add some small random perturbation to eliminate possible cycles.<br/><br/>That's it!</div><div class="commentbar"><p/><span class="commentbutton" href="http://teachingintrotocs.blogspot.com/feeds/643642656919767570/comments/default"/><a href="http://teachingintrotocs.blogspot.com/feeds/643642656919767570/comments/default"><img class="commenticon" src="/images/feed-icon.png"/> Subscribe to comments</a><![CDATA[  | ]]><a href="http://teachingintrotocs.blogspot.com/2011/10/algorithms-success-story-part-22.html#comment-form"><img class="commenticon" src="/images/post-icon.png"/> Post a comment</a></div></content><updated planet:format="October 07, 2011 12:23 PM">2011-10-07T12:23:00Z</updated><published planet:format="October 07, 2011 12:23 PM">2011-10-07T12:23:00Z</published><category scheme="http://www.blogger.com/atom/ns#" term="TCS"/><author><name>Claire Mathieu</name><email>noreply@blogger.com</email><uri>http://www.blogger.com/profile/10957755706440077623</uri></author><source><id>tag:blogger.com,1999:blog-4068183698747623113</id><category term="TCS"/><category term="Oops"/><category term="technology"/><author><name>Claire Mathieu</name><email>noreply@blogger.com</email><uri>http://www.blogger.com/profile/10957755706440077623</uri></author><link href="http://teachingintrotocs.blogspot.com/feeds/posts/default" rel="http://schemas.google.com/g/2005#feed" type="application/atom+xml"/><link href="http://www.blogger.com/feeds/4068183698747623113/posts/default/-/TCS" rel="self" type="application/atom+xml"/><link href="http://teachingintrotocs.blogspot.com/search/label/TCS" rel="alternate" type="text/html"/><link href="http://pubsubhubbub.appspot.com/" rel="hub" type="text/html"/><title>A CS Professor's blog</title><updated planet:format="August 31, 2018 11:03 AM">2018-08-31T11:03:02Z</updated><planet:module>toc</planet:module><planet:format>atom10</planet:format><planet:http_etag>W/&quot;8089cd57e1113cac488458ecc6b57d2f5d63c2f2cb0051d1de6e12d23ed12d82&quot;</planet:http_etag><planet:http_last_modified>Fri, 31 Aug 2018 11:03:02 GMT</planet:http_last_modified><planet:bozo>false</planet:bozo><planet:items_per_page>40</planet:items_per_page><planet:css-id>claire-mathieu</planet:css-id><planet:face>mathieu.jpeg</planet:face><planet:name>Claire Mathieu</planet:name><planet:filters>category.py?cats=tcs</planet:filters><planet:http_status>200</planet:http_status></source></entry>

