<?xml version="1.0" encoding="utf-8"?><entry xmlns="http://www.w3.org/2005/Atom" xmlns:planet="http://planet.intertwingly.net/"><id>tag:blogger.com,1999:blog-4068183698747623113.post-8870389705309806933</id><link href="http://teachingintrotocs.blogspot.com/feeds/8870389705309806933/comments/default" rel="replies" type="application/atom+xml"/><link href="http://teachingintrotocs.blogspot.com/2011/11/how-to-solve-system-of-linear-equations.html#comment-form" rel="replies" type="text/html"/><link href="http://www.blogger.com/feeds/4068183698747623113/posts/default/8870389705309806933" rel="edit" type="application/atom+xml"/><link href="http://www.blogger.com/feeds/4068183698747623113/posts/default/8870389705309806933" rel="self" type="application/atom+xml"/><link href="http://teachingintrotocs.blogspot.com/2011/11/how-to-solve-system-of-linear-equations.html" rel="alternate" type="text/html"/><title>How to solve a system of linear equations</title><content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml">What could be more boring than solving a system of linear equations, Ax=b? We've all learnt in school how to do it: Gaussian elimination; and we've practiced it until we got sick of it. End of story!<br/><br/>But there are people who are never happy with what they have. Gaussian elimination is too slow, they whine. Polynomial time is not good enough for them. They are afraid that it will fail on massive data, and want something that is fast &quot;<i>for real</i>&quot;. Near-linear time is the goal these days.<br/><br/>They currently focus on a special case: &quot;SDD solvers&quot;, meaning that the matrix A is symmetric and diagonally dominant, meaning that the value on the diagonal is larger than the sum of absolute values of all off-diagonal values on its row. In fact, let us simplify things further and assume that A is the &quot;Laplacian matrix&quot; of a graph - the matrix where rows and columns are indexed by V, where the diagonal entry is the vertex degree, and where the off-diagonal entry is -1 if and only if there is an edge between the two vertices.<br/><br/>So, for that special case, in their anxious search for <i>faster</i> algorithms, people have started playing a game that is the opposite of what we traditionally do in approximation algorithms: instead of giving highest priority to the accuracy of the output, and treating runtime as a second thought, they sacrifice some accuracy in the hope if getting a <i>faster</i> algorithm. Indeed, if we don't insist on finding the exact solution x* of Ax=b, then we can try some iterative method that constructs a sequence x1,x2,x3,., where each xi is an improvement over the previous one, and pray that it gets <i>quickly</i> to a value xT close to x*.<br/><br/>But scientists don't trust the power of prayer. Instead, we analyze the <i>runtime</i>, which is basically the cost of each iteration times the number of iterations. Unfortunately, if the matrix A is dense (many non-zero entries), each iteration is costly; and if it's not well-rounded, one needs a large number of iterations to get close to x*.<br/><br/>To <i>speedup</i> the algorithm, instead of solving the system Ax=b, let us solve the equivalent system<br/>      <center>        B^{-1}Ax=B^{-1}b</center><br/>for a well-chosen matrix B. Namely, B should be sparse, so that each iteration is <i>cheap</i>, and B should be similar to A, so that few iterations suffice to converge. (What's the measure of similarity? It's k such that for any vector x,  x^TBx is between x^TAx and k times that quantity.)<br/><br/>Fortunately, there is an algorithm to find a matrix B that is very sparse- only a linear number of non-zero entries - and very well conditioned - k is constant. Unfortunately, that algorithm is <i>slow</i>, which defeats the whole purpose. So, how can one go about <i>quickly</i> finding a good matrix B?<br/><br/>Here's an algorithm for that subproblem.<br/><br/>1. First, find a low-stretch spanning tree T of G, the graph corresponding to A: it's a spanning tree such that the sum of all interpoint distances in T is not much more than the sum of all interpoint distances in G. That's been studied before in a sequence of papers, so it's just a matter of recycling old work.<br/><br/>2. Second, for every edge uv of G, define P(uv) as the distance from u to v in T. Let t be the sum of P(e) over all edges e of G.<br/><br/>3. Third, build a multigraph H  by repeating t log(n) times: <br/>pick an edge e with probability P(e)/t, and put t/P(e) copies of e in H.<br/><br/>4. The desired matrix B is (1/t log(n)) times the Laplacian matrix of H.<br/><br/><br/>And that is what I learned because of a seminar given at Brown by Richard Peng, who presented some more advanced stuff in the same area (some work he's done with Ioannis Koutis and Gary Miller).<br/><br/>Why should we care about this line of research? Getting an improved polynomial-time algorithm for a special case of linear system solvers, is that really such a big deal? Why is there so much interest for those papers in the Theory community? Pick your answer:<br/><br/>( a ) . we should care, because Dan Spielman (or insert the name of your favorite researcher in that area) cares, and he has good taste. [Trust of authorities]<br/>( b ) . we should care, because the algorithmic perspective on those problems is pretty new. It's the development of a new technique. [Algorithmic design]<br/>( c ) . we should care, because this has been implemented and tested and it is claimed to be competitive with existing solvers, so it leads, maybe, to actual real life programs that run faster. This could be a big success story of Theory! [Applications to Applications]<br/>( d ) . we should care, because it has implications for Theory: it leads to faster algorithms for graph problems such as generating a random spanning tree or maximum flow. [Applications to Theory]<br/>( e ) . we should care, because it's sunny out, I am in a good mood, and today I am inclined to see things as exciting in general. [Random]<br/><br/>( a' ) . we should ignore this, because it has too much heavy math, it's not fun, and it's not my taste. [Trust of own taste]<br/>( b' ) . we should ignore this, because the core of it is just low-stretch algorithms, sampling, etc: it's just putting together basic algorithmic tools that have nothing new about them, and the claim of novelty are pure marketing [Disgruntled]<br/>( c' ) . we should ignore this, because the claims of applications are merely what people always say in their introductions, and those claims never mean anything. [Skepticism]<br/>( d' ) . we should ignore this, because it's not going to help understand the P versus NP problem, even in the long term. [Lack of applications to Theory]<br/>( e' ) . we should ignore this, because I had too much to eat and now I have a stomachache. [Random]</div><div class="commentbar"><p/><span class="commentbutton" href="http://teachingintrotocs.blogspot.com/feeds/8870389705309806933/comments/default"/><a href="http://teachingintrotocs.blogspot.com/feeds/8870389705309806933/comments/default"><img class="commenticon" src="/images/feed-icon.png"/> Subscribe to comments</a><![CDATA[  | ]]><a href="http://teachingintrotocs.blogspot.com/2011/11/how-to-solve-system-of-linear-equations.html#comment-form"><img class="commenticon" src="/images/post-icon.png"/> Post a comment</a></div></content><updated planet:format="November 18, 2011 12:17 PM">2011-11-18T12:17:00Z</updated><published planet:format="November 18, 2011 12:17 PM">2011-11-18T12:17:00Z</published><category scheme="http://www.blogger.com/atom/ns#" term="TCS"/><author><name>Claire Mathieu</name><email>noreply@blogger.com</email><uri>http://www.blogger.com/profile/10957755706440077623</uri></author><source><id>tag:blogger.com,1999:blog-4068183698747623113</id><category term="TCS"/><category term="Oops"/><category term="technology"/><author><name>Claire Mathieu</name><email>noreply@blogger.com</email><uri>http://www.blogger.com/profile/10957755706440077623</uri></author><link href="http://teachingintrotocs.blogspot.com/feeds/posts/default" rel="http://schemas.google.com/g/2005#feed" type="application/atom+xml"/><link href="http://www.blogger.com/feeds/4068183698747623113/posts/default/-/TCS" rel="self" type="application/atom+xml"/><link href="http://teachingintrotocs.blogspot.com/search/label/TCS" rel="alternate" type="text/html"/><link href="http://pubsubhubbub.appspot.com/" rel="hub" type="text/html"/><title>A CS Professor's blog</title><updated planet:format="August 31, 2018 11:03 AM">2018-08-31T11:03:02Z</updated><planet:module>toc</planet:module><planet:format>atom10</planet:format><planet:http_etag>W/&quot;8089cd57e1113cac488458ecc6b57d2f5d63c2f2cb0051d1de6e12d23ed12d82&quot;</planet:http_etag><planet:http_last_modified>Fri, 31 Aug 2018 11:03:02 GMT</planet:http_last_modified><planet:bozo>false</planet:bozo><planet:items_per_page>40</planet:items_per_page><planet:css-id>claire-mathieu</planet:css-id><planet:face>mathieu.jpeg</planet:face><planet:name>Claire Mathieu</planet:name><planet:filters>category.py?cats=tcs</planet:filters><planet:http_status>200</planet:http_status></source></entry>

