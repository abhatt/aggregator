<?xml version="1.0" encoding="utf-8"?><entry xml:lang="en-US" xmlns="http://www.w3.org/2005/Atom" xmlns:planet="http://planet.intertwingly.net/"><id>http://xrds.acm.org/blog/?p=1198</id><link href="https://blog.xrds.acm.org/2014/04/big-data-communication-and-lower-bounds/" rel="alternate" type="text/html"/><title>Big Data, Communication and Lower Bounds</title><summary type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p>As the size of the available data increases, massive data sets cannot be stored in their entirety in memory of a single machine. Furthermore due to the small amount of memory and computation power available on a single node, one … <a href="https://blog.xrds.acm.org/2014/04/big-data-communication-and-lower-bounds/">Continue reading <span class="meta-nav">→</span></a></p>
<p>The post <a href="https://blog.xrds.acm.org/2014/04/big-data-communication-and-lower-bounds/" rel="nofollow">Big Data, Communication and Lower Bounds</a> appeared first on <a href="https://blog.xrds.acm.org" rel="nofollow">XRDS</a>.</p></div><div class="commentbar"><p/></div></summary><content type="xhtml"><div xmlns="http://www.w3.org/1999/xhtml"><p style="text-align: left;">As the size of the available data increases, massive data sets cannot be stored in their entirety in memory of a single machine. Furthermore due to the small amount of memory and computation power available on a single node, one needs to distribute the data and computation among multiple machines when processing tasks.</p>
<p style="text-align: left;">However, transferring the big data is very expensive. In fact, it is more expensive than the computations on the datasets. Thus, in the distributed model, the amount of communication plays an important role in the total cost of an algorithm and the aim is to minimize the amount of communication among processors (CPUs). This is one of the main motivations to study the theory of Communication Complexity, which originates from Big Data processing.<span id="more-1198"/></p>
<p style="text-align: left;">
Communication Complexity (CC) has a rich theory behind it and exhibits a beautiful mathematical structure which can be explored by using various mathematical tools.<br/>
In fact, Communication Complexity can be applied to many different problems from theory of computation to other related fields, making this area a fundamental key in our understanding of computation.</p>
<p style="text-align: left;">
CC studies the amount of communication bits that the participants of a communication system need to exchange in order to perform certain tasks. A very simple model for exploring this type of questions was proposed by Yao et. al. in 1979[<a href="http://dl.acm.org/citation.cfm?id=804414">1</a>]. In their model there are two parties, denoted as Alice and Bob and their goal is to compute some specific function f(x, y), which x is input for Alice and y is input for Bob. The results proven in this model can be generalized to more complicated scenarios as well.</p>
<p style="text-align: left;">
Although, at first glance it seems that the field of communication complexity is mostly related to problems in which explicit communication is involved, such as distributed computing, the fact is that its applications are much broader, some of which communication does not even appear in the problem. Examples of such problems are: designing Boolean Circuits, Networks and Data Structures, in particular with regards to computing the lower bounds on the related cost in these type of problems.</p>
<div class="wp-caption alignnone" id="attachment_1222" style="width: 650px;"><a href="http://xrds.acm.org/blog/wp-content/uploads/2014/04/8097457581_2651abd9a5_z.jpg"><img alt="Image licensed in CC 2.0 by Jonny Goldstein" class="size-full wp-image-1222" height="431" src="http://xrds.acm.org/blog/wp-content/uploads/2014/04/8097457581_2651abd9a5_z.jpg" width="640"/></a><p class="wp-caption-text">Image licensed in <a href="https://www.flickr.com/photos/jonnygoldstein/8097457581/in/photostream/" target="_blank">CC 2.0</a> by <a href="https://www.flickr.com/photos/jonnygoldstein/" target="_blank">Jonny Goldstein</a></p></div>
<p style="text-align: left;">It might be surprising and odd that CC can be applied to problems in which communication is not involved. Thus, here I discuss about a few basic problems which communication complexity plays a key role:</p>
<p style="text-align: left;"><strong>Distributed Learning via CC:<br/>
</strong><br/>
Let’s consider a framework where the data is distributed between different locations and parties (each having an arbitrary partition of an overall dataset) and our main goal is to learn a low error hypothesis with respect to the overall distribution of data, using as small amount of communication and as few rounds of communication, as possible, i.e. in distributed learning we are looking for applicable techniques for achieving communication-efficient learning. Different problems such as classification, optimization and differential privacy have been discussed in this setting in some recent work [<a href="http://www.cc.gatech.edu/~ninamf/papers/distributed_learning.pdf">2</a>, <a href="http://arxiv.org/abs/1204.3523">3</a>, <a href="http://arxiv.org/abs/1202.6078">4</a>].</p>
<p style="text-align: left;"><strong>Data Outsourcing and Streaming Interactive Proofs via CC:<br/>
</strong><br/>
When the dataset is fairly large, the data owner cannot retain all the data and so the storage and computation needs to be outsourced to some service provider. In such situations, data owners wants to rest assured that the computations performed by service provider are correct and complete. We can model this scenario by a verification protocol over data stream, in which there is a resource-limited verifier V and more powerful prover P. The verifier starts a conversation with the prover which does the computations and solves the problem. Then, the prover sends a proof to show the validity of his answer and convince the verifier to accept its results. The streaming data models the incremental pass over the data by the verifier as it sends the data to the cloud. In this setting, verifier just requires tracking logarithmic amount of the data, but instead this requires the communication of information among the players. Here, the goal is to design an interactive proof system [<a href="http://en.wikipedia.org/wiki/Interactive_proof_system">5</a>] with logarithmic communication to verify each query, i.e. after seeing the input and the proof, the verifier should be able to verify the proof of a correct statement with high probability, and reject every possible proof which is presented for a wrong statement. Note that here we consider a more powerful verifier by allowing probabilistic verification. This way the problem of verification in cloud computing for massive data streams links to the communication complexity theory and Arthur-Merlin games [<a href="http://en.wikipedia.org/wiki/Arthur%E2%80%93Merlin_protocol">6</a>]. There has been a series of works on streaming interactive proofs for different problems, which can be found in [<a href="http://people.seas.harvard.edu/~jthaler/thesis.pdf">7</a>].</p>
<p style="text-align: left;"><strong>Data Structure Lower Bound via CC:<br/>
</strong><br/>
Here the golden key is to discover the link between communication complexity and data structure and then use this connection to prove lower bounds for data structures supporting certain type of queries. For example, consider we want to design an efficient data structure for answering the queries of type “is i in S?”. To evaluate the quality of the implementation, there are two measures: (1) space which is the total number of memory cells which is used; and, (2) time which is the number of accesses (reads or writes) to the memory needed to accomplish a task and answer a query. This data structure problem can be viewed as a communication complexity problem by setting two parties: One party (Alice) gets as an input a set S and the other party (Bob) gets as an input an element i. The goal is to check whether i is in S. It can be shown that any implementation for the data structure problem can be reduced to a protocol in communication complexity problem in which complexity is related to the complexity of the data structure and as a result, bound for the communication complexity implies the time-space trade-off for the corresponding data structure.</p>
<p style="text-align: left;">
A simple scenario to show this connection is as follows: suppose there is a cell-probe algorithm [<a href="http://stackoverflow.com/questions/15728520/cell-probe-model">8</a>] for a problem which uses a data structure with space s and t queries. This results in a communication protocol for the same problem with communication t (w + log s) in the following way: when the processor asks for the contents of a memory cell, this can be done by Alice sending a message of log s bits, indicating the index of the desired cell and Bob answers with w bits to describe the content of the cell and this scenario will be done in t rounds of communication. A nice study of communication complexity techniques for computing data structure lower bounds can be found in [<a href="http://erikdemaine.org/theses/mpatrascu.pdf">9</a>].</p>
<p style="text-align: left;"><strong>Property Testing Lower Bound via CC:<br/>
</strong><br/>
Property testing was discussed in a previous [<a href="http://xrds.acm.org/blog/2013/11/ultra-efficient-via-sublinearity-2/">post</a>] as a type of sublinear algorithms. To recap, in here our goal is to formalize the question “what can be determined about a large object when we have limited access to it?”. Studies show that there is strong connection between testing and communication complexity [<a href="http://web.mit.edu/matulef/www/papers/PTviaCC-camera.pdf">10</a>]. The biggest similarity is that both involve parties (tester and communication players) with unbounded computational power and restricted access to their input.</p>
<p style="text-align: left;">
In [<a href="http://web.mit.edu/matulef/www/papers/PTviaCC-camera.pdf">10</a>] they consider the case where the large object is the Boolean function f on n input bits and the goal is to decide whether this function has the property P. A variety of techniques and algorithms have been developed for testing Boolean functions, but what distinguishes this work is that they propose techniques for reducing property testing to communication complexity and use this connection for proving lower bounds in certain types of testing problems.</p>
<p style="text-align: left;">
The main idea behind the reduction from testing to communication complexity problem is to set up a communication game as follows: Alice has a function f and Bob has a function g as inputs and they want to check if the joint function h, which is some combination of functions f and g, has a particular property P or is \epsilon-far from all the functions which have the property P. In this setting, now the link is that the number of required queries for testing whether function h has this property will be related to the number of bits which Alice and Bob need to communicate to do this task.</p>
<p style="text-align: left;">As you can see from what we discussed above, the cases in which communication is not explicitly used, communication complexity is used for proving lower bounds. The communication complexity framework has been well-studied and there are several basic problems which are known to require a large amount of communication. Then, the hardness of these and related problems has been used to obtain lower bounds in many areas such as streaming algorithms, circuit complexity, data structures, proof complexity and property testing. The basic idea used here is as follows: in some specific problem that we would like to bound, instead of starting from “scratch” by studying the structure of the problem, we try to find a connection between that and a hard communication problem in which probably the communication complexity is well known . If we can ﬁnd such a connection, then we can reduce the work involved for proving new bounds, or give simpler proofs of known bounds.</p>
<p>Now maybe the big question here is that why we care about computing lower bounds and what is important about it?<br/>
Observe the main difference between upper bounds and lower bounds [<a href="http://cs.au.dk/~larsen/papers/dissertation.pdf">11</a>]: Upper bounds show the existence of an efficient solution, while lower bounds must say something about all possible solutions even those which no one has thought of yet. So it’s not surprising that proving some non-trivial lower bound is significantly harder than obtaining some non-trivial upper bound. The natural goal when proving lower bounds is of course to show that the upper bounds we know for some problem are optimal, i.e. there cannot exist a faster data structure than the one we already have.</p>
<p>Now think of big data: after decades of research, we arrived at efficient solutions for most of the well-known problems in the field, i.e., the upper bounds. However, since we are dealing with massive data sets, even a small improvement in the performance of any key algorithms or data structure, would have a huge impact.<br/>
Thus researchers strive to improve the known solutions. But when does it end? Can we always improve the solutions we have? Or is there some limit to how efficiently a data structure problem can be solved? This is exactly the question addressed by lower bounds. Lower bounds are mathematical functions putting a limit on the performance of algorithms and data structures [<a href="http://cs.au.dk/~larsen/papers/dissertation.pdf">11</a>].</p>
<p>As the concluding remark, it seems that theory of communication complexity and techniques for proving lower bounds serve as two important tools for improving our power to design efficient algorithms and data structures for massive data.</p>
<p>The post <a href="https://blog.xrds.acm.org/2014/04/big-data-communication-and-lower-bounds/" rel="nofollow">Big Data, Communication and Lower Bounds</a> appeared first on <a href="https://blog.xrds.acm.org" rel="nofollow">XRDS</a>.</p></div></content><updated planet:format="April 28, 2014 04:55 AM">2014-04-28T04:55:12Z</updated><published planet:format="April 28, 2014 04:55 AM">2014-04-28T04:55:12Z</published><category term="Algorithms"/><category term="Theory"/><author><name>Samira Daruki</name></author><source><id>https://blog.xrds.acm.org</id><link href="https://blog.xrds.acm.org/tag/theory/feed/" rel="self" type="application/atom+xml"/><link href="https://blog.xrds.acm.org" rel="alternate" type="text/html"/><subtitle>Crossroads - The ACM Magazine for Students</subtitle><title>Theory – XRDS</title><updated planet:format="December 16, 2018 04:43 PM">2018-12-16T16:43:41Z</updated><planet:module>toc</planet:module><planet:format>atom10</planet:format><planet:http_etag>&quot;ce816ac0eb47d36445e6791dee738bc7&quot;</planet:http_etag><planet:http_last_modified>Fri, 09 Nov 2018 09:28:27 GMT</planet:http_last_modified><planet:bozo>true</planet:bozo><planet:items_per_page>40</planet:items_per_page><planet:css-id>acm-crossroads-student-magazine</planet:css-id><planet:face>xrds.jpeg</planet:face><planet:name>ACM Crossroads student magazine</planet:name><planet:http_location>https://blog.xrds.acm.org/tag/theory/feed/</planet:http_location><planet:http_status>301</planet:http_status></source></entry>
